{"version":3,"sources":["fake","file:///Users/adamzaczek/Desktop/code-server/lib/vscode/src/vs/base/common/async.ts","file:///Users/adamzaczek/Desktop/code-server/lib/vscode/src/vs/base/common/process.ts","file:///Users/adamzaczek/Desktop/code-server/lib/vscode/src/vs/base/common/path.ts","file:///Users/adamzaczek/Desktop/code-server/lib/vscode/src/vs/base/common/extpath.ts","file:///Users/adamzaczek/Desktop/code-server/lib/vscode/src/vs/base/common/map.ts","file:///Users/adamzaczek/Desktop/code-server/lib/vscode/src/vs/base/common/glob.ts","file:///Users/adamzaczek/Desktop/code-server/lib/vscode/src/vs/base/common/network.ts","file:///Users/adamzaczek/Desktop/code-server/lib/vscode/src/vs/base/common/resources.ts","file:///Users/adamzaczek/Desktop/code-server/lib/vscode/src/vs/workbench/contrib/output/common/outputLinkComputer.ts"],"names":[],"mappings":"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","file":"outputLinkComputer.js","sourcesContent":["}).call(this);","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationToken, CancellationTokenSource } from 'vs/base/common/cancellation';\nimport * as errors from 'vs/base/common/errors';\nimport { Emitter, Event } from 'vs/base/common/event';\nimport { IDisposable, toDisposable } from 'vs/base/common/lifecycle';\nimport { URI } from 'vs/base/common/uri';\n\nexport function isThenable<T>(obj: any): obj is Promise<T> {\n\treturn obj && typeof (<Promise<any>>obj).then === 'function';\n}\n\nexport interface CancelablePromise<T> extends Promise<T> {\n\tcancel(): void;\n}\n\nexport function createCancelablePromise<T>(callback: (token: CancellationToken) => Promise<T>): CancelablePromise<T> {\n\tconst source = new CancellationTokenSource();\n\n\tconst thenable = callback(source.token);\n\tconst promise = new Promise<T>((resolve, reject) => {\n\t\tsource.token.onCancellationRequested(() => {\n\t\t\treject(errors.canceled());\n\t\t});\n\t\tPromise.resolve(thenable).then(value => {\n\t\t\tsource.dispose();\n\t\t\tresolve(value);\n\t\t}, err => {\n\t\t\tsource.dispose();\n\t\t\treject(err);\n\t\t});\n\t});\n\n\treturn <CancelablePromise<T>>new class {\n\t\tcancel() {\n\t\t\tsource.cancel();\n\t\t}\n\t\tthen<TResult1 = T, TResult2 = never>(resolve?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, reject?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2> {\n\t\t\treturn promise.then(resolve, reject);\n\t\t}\n\t\tcatch<TResult = never>(reject?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult> {\n\t\t\treturn this.then(undefined, reject);\n\t\t}\n\t\tfinally(onfinally?: (() => void) | undefined | null): Promise<T> {\n\t\t\treturn promise.finally(onfinally);\n\t\t}\n\t};\n}\n\nexport function raceCancellation<T>(promise: Promise<T>, token: CancellationToken): Promise<T | undefined>;\nexport function raceCancellation<T>(promise: Promise<T>, token: CancellationToken, defaultValue: T): Promise<T>;\nexport function raceCancellation<T>(promise: Promise<T>, token: CancellationToken, defaultValue?: T): Promise<T> {\n\treturn Promise.race([promise, new Promise<T>(resolve => token.onCancellationRequested(() => resolve(defaultValue)))]);\n}\n\nexport function raceTimeout<T>(promise: Promise<T>, timeout: number, onTimeout?: () => void): Promise<T> {\n\tlet promiseResolve: (() => void) | undefined = undefined;\n\n\tconst timer = setTimeout(() => {\n\t\tpromiseResolve?.();\n\t\tonTimeout?.();\n\t}, timeout);\n\n\treturn Promise.race([\n\t\tpromise.finally(() => clearTimeout(timer)),\n\t\tnew Promise<T>(resolve => promiseResolve = resolve)\n\t]);\n}\n\nexport function asPromise<T>(callback: () => T | Thenable<T>): Promise<T> {\n\treturn new Promise<T>((resolve, reject) => {\n\t\tconst item = callback();\n\t\tif (isThenable<T>(item)) {\n\t\t\titem.then(resolve, reject);\n\t\t} else {\n\t\t\tresolve(item);\n\t\t}\n\t});\n}\n\nexport interface ITask<T> {\n\t(): T;\n}\n\n/**\n * A helper to prevent accumulation of sequential async tasks.\n *\n * Imagine a mail man with the sole task of delivering letters. As soon as\n * a letter submitted for delivery, he drives to the destination, delivers it\n * and returns to his base. Imagine that during the trip, N more letters were submitted.\n * When the mail man returns, he picks those N letters and delivers them all in a\n * single trip. Even though N+1 submissions occurred, only 2 deliveries were made.\n *\n * The throttler implements this via the queue() method, by providing it a task\n * factory. Following the example:\n *\n * \t\tconst throttler = new Throttler();\n * \t\tconst letters = [];\n *\n * \t\tfunction deliver() {\n * \t\t\tconst lettersToDeliver = letters;\n * \t\t\tletters = [];\n * \t\t\treturn makeTheTrip(lettersToDeliver);\n * \t\t}\n *\n * \t\tfunction onLetterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tthrottler.queue(deliver);\n * \t\t}\n */\nexport class Throttler {\n\n\tprivate activePromise: Promise<any> | null;\n\tprivate queuedPromise: Promise<any> | null;\n\tprivate queuedPromiseFactory: ITask<Promise<any>> | null;\n\n\tconstructor() {\n\t\tthis.activePromise = null;\n\t\tthis.queuedPromise = null;\n\t\tthis.queuedPromiseFactory = null;\n\t}\n\n\tqueue<T>(promiseFactory: ITask<Promise<T>>): Promise<T> {\n\t\tif (this.activePromise) {\n\t\t\tthis.queuedPromiseFactory = promiseFactory;\n\n\t\t\tif (!this.queuedPromise) {\n\t\t\t\tconst onComplete = () => {\n\t\t\t\t\tthis.queuedPromise = null;\n\n\t\t\t\t\tconst result = this.queue(this.queuedPromiseFactory!);\n\t\t\t\t\tthis.queuedPromiseFactory = null;\n\n\t\t\t\t\treturn result;\n\t\t\t\t};\n\n\t\t\t\tthis.queuedPromise = new Promise(c => {\n\t\t\t\t\tthis.activePromise!.then(onComplete, onComplete).then(c);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn new Promise((c, e) => {\n\t\t\t\tthis.queuedPromise!.then(c, e);\n\t\t\t});\n\t\t}\n\n\t\tthis.activePromise = promiseFactory();\n\n\t\treturn new Promise((c, e) => {\n\t\t\tthis.activePromise!.then((result: any) => {\n\t\t\t\tthis.activePromise = null;\n\t\t\t\tc(result);\n\t\t\t}, (err: any) => {\n\t\t\t\tthis.activePromise = null;\n\t\t\t\te(err);\n\t\t\t});\n\t\t});\n\t}\n}\n\nexport class Sequencer {\n\n\tprivate current: Promise<any> = Promise.resolve(null);\n\n\tqueue<T>(promiseTask: ITask<Promise<T>>): Promise<T> {\n\t\treturn this.current = this.current.then(() => promiseTask());\n\t}\n}\n\n/**\n * A helper to delay execution of a task that is being requested often.\n *\n * Following the throttler, now imagine the mail man wants to optimize the number of\n * trips proactively. The trip itself can be long, so he decides not to make the trip\n * as soon as a letter is submitted. Instead he waits a while, in case more\n * letters are submitted. After said waiting period, if no letters were submitted, he\n * decides to make the trip. Imagine that N more letters were submitted after the first\n * one, all within a short period of time between each other. Even though N+1\n * submissions occurred, only 1 delivery was made.\n *\n * The delayer offers this behavior via the trigger() method, into which both the task\n * to be executed and the waiting period (delay) must be passed in as arguments. Following\n * the example:\n *\n * \t\tconst delayer = new Delayer(WAITING_PERIOD);\n * \t\tconst letters = [];\n *\n * \t\tfunction letterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tdelayer.trigger(() => { return makeTheTrip(); });\n * \t\t}\n */\nexport class Delayer<T> implements IDisposable {\n\n\tprivate timeout: any;\n\tprivate completionPromise: Promise<any> | null;\n\tprivate doResolve: ((value?: any | Promise<any>) => void) | null;\n\tprivate doReject: ((err: any) => void) | null;\n\tprivate task: ITask<T | Promise<T>> | null;\n\n\tconstructor(public defaultDelay: number) {\n\t\tthis.timeout = null;\n\t\tthis.completionPromise = null;\n\t\tthis.doResolve = null;\n\t\tthis.doReject = null;\n\t\tthis.task = null;\n\t}\n\n\ttrigger(task: ITask<T | Promise<T>>, delay: number = this.defaultDelay): Promise<T> {\n\t\tthis.task = task;\n\t\tthis.cancelTimeout();\n\n\t\tif (!this.completionPromise) {\n\t\t\tthis.completionPromise = new Promise((c, e) => {\n\t\t\t\tthis.doResolve = c;\n\t\t\t\tthis.doReject = e;\n\t\t\t}).then(() => {\n\t\t\t\tthis.completionPromise = null;\n\t\t\t\tthis.doResolve = null;\n\t\t\t\tif (this.task) {\n\t\t\t\t\tconst task = this.task;\n\t\t\t\t\tthis.task = null;\n\t\t\t\t\treturn task();\n\t\t\t\t}\n\t\t\t\treturn undefined;\n\t\t\t});\n\t\t}\n\n\t\tthis.timeout = setTimeout(() => {\n\t\t\tthis.timeout = null;\n\t\t\tif (this.doResolve) {\n\t\t\t\tthis.doResolve(null);\n\t\t\t}\n\t\t}, delay);\n\n\t\treturn this.completionPromise;\n\t}\n\n\tisTriggered(): boolean {\n\t\treturn this.timeout !== null;\n\t}\n\n\tcancel(): void {\n\t\tthis.cancelTimeout();\n\n\t\tif (this.completionPromise) {\n\t\t\tif (this.doReject) {\n\t\t\t\tthis.doReject(errors.canceled());\n\t\t\t}\n\t\t\tthis.completionPromise = null;\n\t\t}\n\t}\n\n\tprivate cancelTimeout(): void {\n\t\tif (this.timeout !== null) {\n\t\t\tclearTimeout(this.timeout);\n\t\t\tthis.timeout = null;\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tthis.cancelTimeout();\n\t}\n}\n\n/**\n * A helper to delay execution of a task that is being requested often, while\n * preventing accumulation of consecutive executions, while the task runs.\n *\n * The mail man is clever and waits for a certain amount of time, before going\n * out to deliver letters. While the mail man is going out, more letters arrive\n * and can only be delivered once he is back. Once he is back the mail man will\n * do one more trip to deliver the letters that have accumulated while he was out.\n */\nexport class ThrottledDelayer<T> {\n\n\tprivate delayer: Delayer<Promise<T>>;\n\tprivate throttler: Throttler;\n\n\tconstructor(defaultDelay: number) {\n\t\tthis.delayer = new Delayer(defaultDelay);\n\t\tthis.throttler = new Throttler();\n\t}\n\n\ttrigger(promiseFactory: ITask<Promise<T>>, delay?: number): Promise<T> {\n\t\treturn this.delayer.trigger(() => this.throttler.queue(promiseFactory), delay) as any as Promise<T>;\n\t}\n\n\tisTriggered(): boolean {\n\t\treturn this.delayer.isTriggered();\n\t}\n\n\tcancel(): void {\n\t\tthis.delayer.cancel();\n\t}\n\n\tdispose(): void {\n\t\tthis.delayer.dispose();\n\t}\n}\n\n/**\n * A barrier that is initially closed and then becomes opened permanently.\n */\nexport class Barrier {\n\n\tprivate _isOpen: boolean;\n\tprivate _promise: Promise<boolean>;\n\tprivate _completePromise!: (v: boolean) => void;\n\n\tconstructor() {\n\t\tthis._isOpen = false;\n\t\tthis._promise = new Promise<boolean>((c, e) => {\n\t\t\tthis._completePromise = c;\n\t\t});\n\t}\n\n\tisOpen(): boolean {\n\t\treturn this._isOpen;\n\t}\n\n\topen(): void {\n\t\tthis._isOpen = true;\n\t\tthis._completePromise(true);\n\t}\n\n\twait(): Promise<boolean> {\n\t\treturn this._promise;\n\t}\n}\n\nexport function timeout(millis: number): CancelablePromise<void>;\nexport function timeout(millis: number, token: CancellationToken): Promise<void>;\nexport function timeout(millis: number, token?: CancellationToken): CancelablePromise<void> | Promise<void> {\n\tif (!token) {\n\t\treturn createCancelablePromise(token => timeout(millis, token));\n\t}\n\n\treturn new Promise((resolve, reject) => {\n\t\tconst handle = setTimeout(resolve, millis);\n\t\ttoken.onCancellationRequested(() => {\n\t\t\tclearTimeout(handle);\n\t\t\treject(errors.canceled());\n\t\t});\n\t});\n}\n\nexport function disposableTimeout(handler: () => void, timeout = 0): IDisposable {\n\tconst timer = setTimeout(handler, timeout);\n\treturn toDisposable(() => clearTimeout(timer));\n}\n\nexport function ignoreErrors<T>(promise: Promise<T>): Promise<T | undefined> {\n\treturn promise.then(undefined, _ => undefined);\n}\n\n/**\n * Runs the provided list of promise factories in sequential order. The returned\n * promise will complete to an array of results from each promise.\n */\n\nexport function sequence<T>(promiseFactories: ITask<Promise<T>>[]): Promise<T[]> {\n\tconst results: T[] = [];\n\tlet index = 0;\n\tconst len = promiseFactories.length;\n\n\tfunction next(): Promise<T> | null {\n\t\treturn index < len ? promiseFactories[index++]() : null;\n\t}\n\n\tfunction thenHandler(result: any): Promise<any> {\n\t\tif (result !== undefined && result !== null) {\n\t\t\tresults.push(result);\n\t\t}\n\n\t\tconst n = next();\n\t\tif (n) {\n\t\t\treturn n.then(thenHandler);\n\t\t}\n\n\t\treturn Promise.resolve(results);\n\t}\n\n\treturn Promise.resolve(null).then(thenHandler);\n}\n\nexport function first<T>(promiseFactories: ITask<Promise<T>>[], shouldStop: (t: T) => boolean = t => !!t, defaultValue: T | null = null): Promise<T | null> {\n\tlet index = 0;\n\tconst len = promiseFactories.length;\n\n\tconst loop: () => Promise<T | null> = () => {\n\t\tif (index >= len) {\n\t\t\treturn Promise.resolve(defaultValue);\n\t\t}\n\n\t\tconst factory = promiseFactories[index++];\n\t\tconst promise = Promise.resolve(factory());\n\n\t\treturn promise.then(result => {\n\t\t\tif (shouldStop(result)) {\n\t\t\t\treturn Promise.resolve(result);\n\t\t\t}\n\n\t\t\treturn loop();\n\t\t});\n\t};\n\n\treturn loop();\n}\n\ninterface ILimitedTaskFactory<T> {\n\tfactory: ITask<Promise<T>>;\n\tc: (value?: T | Promise<T>) => void;\n\te: (error?: any) => void;\n}\n\n/**\n * A helper to queue N promises and run them all with a max degree of parallelism. The helper\n * ensures that at any time no more than M promises are running at the same time.\n */\nexport class Limiter<T> {\n\n\tprivate _size = 0;\n\tprivate runningPromises: number;\n\tprivate maxDegreeOfParalellism: number;\n\tprivate outstandingPromises: ILimitedTaskFactory<T>[];\n\tprivate readonly _onFinished: Emitter<void>;\n\n\tconstructor(maxDegreeOfParalellism: number) {\n\t\tthis.maxDegreeOfParalellism = maxDegreeOfParalellism;\n\t\tthis.outstandingPromises = [];\n\t\tthis.runningPromises = 0;\n\t\tthis._onFinished = new Emitter<void>();\n\t}\n\n\tget onFinished(): Event<void> {\n\t\treturn this._onFinished.event;\n\t}\n\n\tget size(): number {\n\t\treturn this._size;\n\t\t// return this.runningPromises + this.outstandingPromises.length;\n\t}\n\n\tqueue(factory: ITask<Promise<T>>): Promise<T> {\n\t\tthis._size++;\n\n\t\treturn new Promise<T>((c, e) => {\n\t\t\tthis.outstandingPromises.push({ factory, c, e });\n\t\t\tthis.consume();\n\t\t});\n\t}\n\n\tprivate consume(): void {\n\t\twhile (this.outstandingPromises.length && this.runningPromises < this.maxDegreeOfParalellism) {\n\t\t\tconst iLimitedTask = this.outstandingPromises.shift()!;\n\t\t\tthis.runningPromises++;\n\n\t\t\tconst promise = iLimitedTask.factory();\n\t\t\tpromise.then(iLimitedTask.c, iLimitedTask.e);\n\t\t\tpromise.then(() => this.consumed(), () => this.consumed());\n\t\t}\n\t}\n\n\tprivate consumed(): void {\n\t\tthis._size--;\n\t\tthis.runningPromises--;\n\n\t\tif (this.outstandingPromises.length > 0) {\n\t\t\tthis.consume();\n\t\t} else {\n\t\t\tthis._onFinished.fire();\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tthis._onFinished.dispose();\n\t}\n}\n\n/**\n * A queue is handles one promise at a time and guarantees that at any time only one promise is executing.\n */\nexport class Queue<T> extends Limiter<T> {\n\n\tconstructor() {\n\t\tsuper(1);\n\t}\n}\n\n/**\n * A helper to organize queues per resource. The ResourceQueue makes sure to manage queues per resource\n * by disposing them once the queue is empty.\n */\nexport class ResourceQueue implements IDisposable {\n\n\tprivate readonly queues = new Map<string, Queue<void>>();\n\n\tqueueFor(resource: URI): Queue<void> {\n\t\tconst key = resource.toString();\n\t\tif (!this.queues.has(key)) {\n\t\t\tconst queue = new Queue<void>();\n\t\t\tqueue.onFinished(() => {\n\t\t\t\tqueue.dispose();\n\t\t\t\tthis.queues.delete(key);\n\t\t\t});\n\n\t\t\tthis.queues.set(key, queue);\n\t\t}\n\n\t\treturn this.queues.get(key)!;\n\t}\n\n\tdispose(): void {\n\t\tthis.queues.forEach(queue => queue.dispose());\n\t\tthis.queues.clear();\n\t}\n}\n\nexport class TimeoutTimer implements IDisposable {\n\tprivate _token: any;\n\n\tconstructor();\n\tconstructor(runner: () => void, timeout: number);\n\tconstructor(runner?: () => void, timeout?: number) {\n\t\tthis._token = -1;\n\n\t\tif (typeof runner === 'function' && typeof timeout === 'number') {\n\t\t\tthis.setIfNotSet(runner, timeout);\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t}\n\n\tcancel(): void {\n\t\tif (this._token !== -1) {\n\t\t\tclearTimeout(this._token);\n\t\t\tthis._token = -1;\n\t\t}\n\t}\n\n\tcancelAndSet(runner: () => void, timeout: number): void {\n\t\tthis.cancel();\n\t\tthis._token = setTimeout(() => {\n\t\t\tthis._token = -1;\n\t\t\trunner();\n\t\t}, timeout);\n\t}\n\n\tsetIfNotSet(runner: () => void, timeout: number): void {\n\t\tif (this._token !== -1) {\n\t\t\t// timer is already set\n\t\t\treturn;\n\t\t}\n\t\tthis._token = setTimeout(() => {\n\t\t\tthis._token = -1;\n\t\t\trunner();\n\t\t}, timeout);\n\t}\n}\n\nexport class IntervalTimer implements IDisposable {\n\n\tprivate _token: any;\n\n\tconstructor() {\n\t\tthis._token = -1;\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t}\n\n\tcancel(): void {\n\t\tif (this._token !== -1) {\n\t\t\tclearInterval(this._token);\n\t\t\tthis._token = -1;\n\t\t}\n\t}\n\n\tcancelAndSet(runner: () => void, interval: number): void {\n\t\tthis.cancel();\n\t\tthis._token = setInterval(() => {\n\t\t\trunner();\n\t\t}, interval);\n\t}\n}\n\nexport class RunOnceScheduler {\n\n\tprotected runner: ((...args: any[]) => void) | null;\n\n\tprivate timeoutToken: any;\n\tprivate timeout: number;\n\tprivate timeoutHandler: () => void;\n\n\tconstructor(runner: (...args: any[]) => void, timeout: number) {\n\t\tthis.timeoutToken = -1;\n\t\tthis.runner = runner;\n\t\tthis.timeout = timeout;\n\t\tthis.timeoutHandler = this.onTimeout.bind(this);\n\t}\n\n\t/**\n\t * Dispose RunOnceScheduler\n\t */\n\tdispose(): void {\n\t\tthis.cancel();\n\t\tthis.runner = null;\n\t}\n\n\t/**\n\t * Cancel current scheduled runner (if any).\n\t */\n\tcancel(): void {\n\t\tif (this.isScheduled()) {\n\t\t\tclearTimeout(this.timeoutToken);\n\t\t\tthis.timeoutToken = -1;\n\t\t}\n\t}\n\n\t/**\n\t * Cancel previous runner (if any) & schedule a new runner.\n\t */\n\tschedule(delay = this.timeout): void {\n\t\tthis.cancel();\n\t\tthis.timeoutToken = setTimeout(this.timeoutHandler, delay);\n\t}\n\n\t/**\n\t * Returns true if scheduled.\n\t */\n\tisScheduled(): boolean {\n\t\treturn this.timeoutToken !== -1;\n\t}\n\n\tprivate onTimeout() {\n\t\tthis.timeoutToken = -1;\n\t\tif (this.runner) {\n\t\t\tthis.doRun();\n\t\t}\n\t}\n\n\tprotected doRun(): void {\n\t\tif (this.runner) {\n\t\t\tthis.runner();\n\t\t}\n\t}\n}\n\nexport class RunOnceWorker<T> extends RunOnceScheduler {\n\tprivate units: T[] = [];\n\n\tconstructor(runner: (units: T[]) => void, timeout: number) {\n\t\tsuper(runner, timeout);\n\t}\n\n\twork(unit: T): void {\n\t\tthis.units.push(unit);\n\n\t\tif (!this.isScheduled()) {\n\t\t\tthis.schedule();\n\t\t}\n\t}\n\n\tprotected doRun(): void {\n\t\tconst units = this.units;\n\t\tthis.units = [];\n\n\t\tif (this.runner) {\n\t\t\tthis.runner(units);\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tthis.units = [];\n\n\t\tsuper.dispose();\n\t}\n}\n\n//#region -- run on idle tricks ------------\n\nexport interface IdleDeadline {\n\treadonly didTimeout: boolean;\n\ttimeRemaining(): number;\n}\n/**\n * Execute the callback the next time the browser is idle\n */\nexport let runWhenIdle: (callback: (idle: IdleDeadline) => void, timeout?: number) => IDisposable;\n\ndeclare function requestIdleCallback(callback: (args: IdleDeadline) => void, options?: { timeout: number }): number;\ndeclare function cancelIdleCallback(handle: number): void;\n\n(function () {\n\tif (typeof requestIdleCallback !== 'function' || typeof cancelIdleCallback !== 'function') {\n\t\tconst dummyIdle: IdleDeadline = Object.freeze({\n\t\t\tdidTimeout: true,\n\t\t\ttimeRemaining() { return 15; }\n\t\t});\n\t\trunWhenIdle = (runner) => {\n\t\t\tconst handle = setTimeout(() => runner(dummyIdle));\n\t\t\tlet disposed = false;\n\t\t\treturn {\n\t\t\t\tdispose() {\n\t\t\t\t\tif (disposed) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tdisposed = true;\n\t\t\t\t\tclearTimeout(handle);\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t} else {\n\t\trunWhenIdle = (runner, timeout?) => {\n\t\t\tconst handle: number = requestIdleCallback(runner, typeof timeout === 'number' ? { timeout } : undefined);\n\t\t\tlet disposed = false;\n\t\t\treturn {\n\t\t\t\tdispose() {\n\t\t\t\t\tif (disposed) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tdisposed = true;\n\t\t\t\t\tcancelIdleCallback(handle);\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t}\n})();\n\n/**\n * An implementation of the \"idle-until-urgent\"-strategy as introduced\n * here: https://philipwalton.com/articles/idle-until-urgent/\n */\nexport class IdleValue<T> {\n\n\tprivate readonly _executor: () => void;\n\tprivate readonly _handle: IDisposable;\n\n\tprivate _didRun: boolean = false;\n\tprivate _value?: T;\n\tprivate _error: any;\n\n\tconstructor(executor: () => T) {\n\t\tthis._executor = () => {\n\t\t\ttry {\n\t\t\t\tthis._value = executor();\n\t\t\t} catch (err) {\n\t\t\t\tthis._error = err;\n\t\t\t} finally {\n\t\t\t\tthis._didRun = true;\n\t\t\t}\n\t\t};\n\t\tthis._handle = runWhenIdle(() => this._executor());\n\t}\n\n\tdispose(): void {\n\t\tthis._handle.dispose();\n\t}\n\n\tgetValue(): T {\n\t\tif (!this._didRun) {\n\t\t\tthis._handle.dispose();\n\t\t\tthis._executor();\n\t\t}\n\t\tif (this._error) {\n\t\t\tthrow this._error;\n\t\t}\n\t\treturn this._value!;\n\t}\n}\n\n//#endregion\n\nexport async function retry<T>(task: ITask<Promise<T>>, delay: number, retries: number): Promise<T> {\n\tlet lastError: Error | undefined;\n\n\tfor (let i = 0; i < retries; i++) {\n\t\ttry {\n\t\t\treturn await task();\n\t\t} catch (error) {\n\t\t\tlastError = error;\n\n\t\t\tawait timeout(delay);\n\t\t}\n\t}\n\n\tthrow lastError;\n}\n\n//#region Task Sequentializer\n\ninterface IPendingTask {\n\ttaskId: number;\n\tcancel: () => void;\n\tpromise: Promise<void>;\n}\n\ninterface ISequentialTask {\n\tpromise: Promise<void>;\n\tpromiseResolve: () => void;\n\tpromiseReject: (error: Error) => void;\n\trun: () => Promise<void>;\n}\n\nexport interface ITaskSequentializerWithPendingTask {\n\treadonly pending: Promise<void>;\n}\n\nexport class TaskSequentializer {\n\tprivate _pending?: IPendingTask;\n\tprivate _next?: ISequentialTask;\n\n\thasPending(taskId?: number): this is ITaskSequentializerWithPendingTask {\n\t\tif (!this._pending) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (typeof taskId === 'number') {\n\t\t\treturn this._pending.taskId === taskId;\n\t\t}\n\n\t\treturn !!this._pending;\n\t}\n\n\tget pending(): Promise<void> | undefined {\n\t\treturn this._pending ? this._pending.promise : undefined;\n\t}\n\n\tcancelPending(): void {\n\t\tthis._pending?.cancel();\n\t}\n\n\tsetPending(taskId: number, promise: Promise<void>, onCancel?: () => void, ): Promise<void> {\n\t\tthis._pending = { taskId: taskId, cancel: () => onCancel?.(), promise };\n\n\t\tpromise.then(() => this.donePending(taskId), () => this.donePending(taskId));\n\n\t\treturn promise;\n\t}\n\n\tprivate donePending(taskId: number): void {\n\t\tif (this._pending && taskId === this._pending.taskId) {\n\n\t\t\t// only set pending to done if the promise finished that is associated with that taskId\n\t\t\tthis._pending = undefined;\n\n\t\t\t// schedule the next task now that we are free if we have any\n\t\t\tthis.triggerNext();\n\t\t}\n\t}\n\n\tprivate triggerNext(): void {\n\t\tif (this._next) {\n\t\t\tconst next = this._next;\n\t\t\tthis._next = undefined;\n\n\t\t\t// Run next task and complete on the associated promise\n\t\t\tnext.run().then(next.promiseResolve, next.promiseReject);\n\t\t}\n\t}\n\n\tsetNext(run: () => Promise<void>): Promise<void> {\n\n\t\t// this is our first next task, so we create associated promise with it\n\t\t// so that we can return a promise that completes when the task has\n\t\t// completed.\n\t\tif (!this._next) {\n\t\t\tlet promiseResolve: () => void;\n\t\t\tlet promiseReject: (error: Error) => void;\n\t\t\tconst promise = new Promise<void>((resolve, reject) => {\n\t\t\t\tpromiseResolve = resolve;\n\t\t\t\tpromiseReject = reject;\n\t\t\t});\n\n\t\t\tthis._next = {\n\t\t\t\trun,\n\t\t\t\tpromise,\n\t\t\t\tpromiseResolve: promiseResolve!,\n\t\t\t\tpromiseReject: promiseReject!\n\t\t\t};\n\t\t}\n\n\t\t// we have a previous next task, just overwrite it\n\t\telse {\n\t\t\tthis._next.run = run;\n\t\t}\n\n\t\treturn this._next.promise;\n\t}\n}\n\n//#endregion\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { isWindows, isMacintosh, setImmediate, IProcessEnvironment } from 'vs/base/common/platform';\n\ninterface IProcess {\n\tplatform: string;\n\tenv: IProcessEnvironment;\n\n\tcwd(): string;\n\tnextTick(callback: (...args: any[]) => void): void;\n}\n\ndeclare const process: IProcess;\nconst safeProcess: IProcess = (typeof process === 'undefined') ? {\n\tcwd(): string { return '/'; },\n\tenv: Object.create(null),\n\tget platform(): string { return isWindows ? 'win32' : isMacintosh ? 'darwin' : 'linux'; },\n\tnextTick(callback: (...args: any[]) => void): void { return setImmediate(callback); }\n} : process;\n\nexport const cwd = safeProcess.cwd;\nexport const env = safeProcess.env;\nexport const platform = safeProcess.platform;\nexport const nextTick = safeProcess.nextTick;\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n// NOTE: VSCode's copy of nodejs path library to be usable in common (non-node) namespace\n// Copied from: https://github.com/nodejs/node/tree/43dd49c9782848c25e5b03448c8a0f923f13c158\n\n/**\n * Copyright Joyent, Inc. and other Node contributors.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n *\n * The above copyright notice and this permission notice shall be included\n * in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n * NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n * USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\nimport * as process from 'vs/base/common/process';\n\nconst CHAR_UPPERCASE_A = 65;/* A */\nconst CHAR_LOWERCASE_A = 97; /* a */\nconst CHAR_UPPERCASE_Z = 90; /* Z */\nconst CHAR_LOWERCASE_Z = 122; /* z */\nconst CHAR_DOT = 46; /* . */\nconst CHAR_FORWARD_SLASH = 47; /* / */\nconst CHAR_BACKWARD_SLASH = 92; /* \\ */\nconst CHAR_COLON = 58; /* : */\nconst CHAR_QUESTION_MARK = 63; /* ? */\n\nclass ErrorInvalidArgType extends Error {\n\tcode: 'ERR_INVALID_ARG_TYPE';\n\tconstructor(name: string, expected: string, actual: any) {\n\t\t// determiner: 'must be' or 'must not be'\n\t\tlet determiner;\n\t\tif (typeof expected === 'string' && expected.indexOf('not ') === 0) {\n\t\t\tdeterminer = 'must not be';\n\t\t\texpected = expected.replace(/^not /, '');\n\t\t} else {\n\t\t\tdeterminer = 'must be';\n\t\t}\n\n\t\tconst type = name.indexOf('.') !== -1 ? 'property' : 'argument';\n\t\tlet msg = `The \"${name}\" ${type} ${determiner} of type ${expected}`;\n\n\t\tmsg += `. Received type ${typeof actual}`;\n\t\tsuper(msg);\n\n\t\tthis.code = 'ERR_INVALID_ARG_TYPE';\n\t}\n}\n\nfunction validateString(value: string, name: string) {\n\tif (typeof value !== 'string') {\n\t\tthrow new ErrorInvalidArgType(name, 'string', value);\n\t}\n}\n\nfunction isPathSeparator(code: number | undefined) {\n\treturn code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\n}\n\nfunction isPosixPathSeparator(code: number | undefined) {\n\treturn code === CHAR_FORWARD_SLASH;\n}\n\nfunction isWindowsDeviceRoot(code: number) {\n\treturn code >= CHAR_UPPERCASE_A && code <= CHAR_UPPERCASE_Z ||\n\t\tcode >= CHAR_LOWERCASE_A && code <= CHAR_LOWERCASE_Z;\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeString(path: string, allowAboveRoot: boolean, separator: string, isPathSeparator: (code?: number) => boolean) {\n\tlet res = '';\n\tlet lastSegmentLength = 0;\n\tlet lastSlash = -1;\n\tlet dots = 0;\n\tlet code;\n\tfor (let i = 0; i <= path.length; ++i) {\n\t\tif (i < path.length) {\n\t\t\tcode = path.charCodeAt(i);\n\t\t}\n\t\telse if (isPathSeparator(code)) {\n\t\t\tbreak;\n\t\t}\n\t\telse {\n\t\t\tcode = CHAR_FORWARD_SLASH;\n\t\t}\n\n\t\tif (isPathSeparator(code)) {\n\t\t\tif (lastSlash === i - 1 || dots === 1) {\n\t\t\t\t// NOOP\n\t\t\t} else if (lastSlash !== i - 1 && dots === 2) {\n\t\t\t\tif (res.length < 2 || lastSegmentLength !== 2 ||\n\t\t\t\t\tres.charCodeAt(res.length - 1) !== CHAR_DOT ||\n\t\t\t\t\tres.charCodeAt(res.length - 2) !== CHAR_DOT) {\n\t\t\t\t\tif (res.length > 2) {\n\t\t\t\t\t\tconst lastSlashIndex = res.lastIndexOf(separator);\n\t\t\t\t\t\tif (lastSlashIndex === -1) {\n\t\t\t\t\t\t\tres = '';\n\t\t\t\t\t\t\tlastSegmentLength = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tres = res.slice(0, lastSlashIndex);\n\t\t\t\t\t\t\tlastSegmentLength = res.length - 1 - res.lastIndexOf(separator);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlastSlash = i;\n\t\t\t\t\t\tdots = 0;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else if (res.length === 2 || res.length === 1) {\n\t\t\t\t\t\tres = '';\n\t\t\t\t\t\tlastSegmentLength = 0;\n\t\t\t\t\t\tlastSlash = i;\n\t\t\t\t\t\tdots = 0;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (allowAboveRoot) {\n\t\t\t\t\tif (res.length > 0) {\n\t\t\t\t\t\tres += `${separator}..`;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tres = '..';\n\t\t\t\t\t}\n\t\t\t\t\tlastSegmentLength = 2;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (res.length > 0) {\n\t\t\t\t\tres += separator + path.slice(lastSlash + 1, i);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tres = path.slice(lastSlash + 1, i);\n\t\t\t\t}\n\t\t\t\tlastSegmentLength = i - lastSlash - 1;\n\t\t\t}\n\t\t\tlastSlash = i;\n\t\t\tdots = 0;\n\t\t} else if (code === CHAR_DOT && dots !== -1) {\n\t\t\t++dots;\n\t\t} else {\n\t\t\tdots = -1;\n\t\t}\n\t}\n\treturn res;\n}\n\nfunction _format(sep: string, pathObject: ParsedPath) {\n\tconst dir = pathObject.dir || pathObject.root;\n\tconst base = pathObject.base ||\n\t\t((pathObject.name || '') + (pathObject.ext || ''));\n\tif (!dir) {\n\t\treturn base;\n\t}\n\tif (dir === pathObject.root) {\n\t\treturn dir + base;\n\t}\n\treturn dir + sep + base;\n}\n\nexport interface ParsedPath {\n\troot: string;\n\tdir: string;\n\tbase: string;\n\text: string;\n\tname: string;\n}\n\nexport interface IPath {\n\tnormalize(path: string): string;\n\tisAbsolute(path: string): boolean;\n\tjoin(...paths: string[]): string;\n\tresolve(...pathSegments: string[]): string;\n\trelative(from: string, to: string): string;\n\tdirname(path: string): string;\n\tbasename(path: string, ext?: string): string;\n\textname(path: string): string;\n\tformat(pathObject: ParsedPath): string;\n\tparse(path: string): ParsedPath;\n\ttoNamespacedPath(path: string): string;\n\tsep: '\\\\' | '/';\n\tdelimiter: string;\n\twin32: IPath | null;\n\tposix: IPath | null;\n}\n\nexport const win32: IPath = {\n\t// path.resolve([from ...], to)\n\tresolve(...pathSegments: string[]): string {\n\t\tlet resolvedDevice = '';\n\t\tlet resolvedTail = '';\n\t\tlet resolvedAbsolute = false;\n\n\t\tfor (let i = pathSegments.length - 1; i >= -1; i--) {\n\t\t\tlet path;\n\t\t\tif (i >= 0) {\n\t\t\t\tpath = pathSegments[i];\n\t\t\t} else if (!resolvedDevice) {\n\t\t\t\tpath = process.cwd();\n\t\t\t} else {\n\t\t\t\t// Windows has the concept of drive-specific current working\n\t\t\t\t// directories. If we've resolved a drive letter but not yet an\n\t\t\t\t// absolute path, get cwd for that drive, or the process cwd if\n\t\t\t\t// the drive cwd is not available. We're sure the device is not\n\t\t\t\t// a UNC path at this points, because UNC paths are always absolute.\n\t\t\t\tpath = (process.env as any)['=' + resolvedDevice] || process.cwd();\n\n\t\t\t\t// Verify that a cwd was found and that it actually points\n\t\t\t\t// to our drive. If not, default to the drive's root.\n\t\t\t\tif (path === undefined ||\n\t\t\t\t\tpath.slice(0, 3).toLowerCase() !==\n\t\t\t\t\tresolvedDevice.toLowerCase() + '\\\\') {\n\t\t\t\t\tpath = resolvedDevice + '\\\\';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvalidateString(path, 'path');\n\n\t\t\t// Skip empty entries\n\t\t\tif (path.length === 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst len = path.length;\n\t\t\tlet rootEnd = 0;\n\t\t\tlet device = '';\n\t\t\tlet isAbsolute = false;\n\t\t\tconst code = path.charCodeAt(0);\n\n\t\t\t// Try to match a root\n\t\t\tif (len > 1) {\n\t\t\t\tif (isPathSeparator(code)) {\n\t\t\t\t\t// Possible UNC root\n\n\t\t\t\t\t// If we started with a separator, we know we at least have an\n\t\t\t\t\t// absolute path of some kind (UNC or otherwise)\n\t\t\t\t\tisAbsolute = true;\n\n\t\t\t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n\t\t\t\t\t\t// Matched double path separator at beginning\n\t\t\t\t\t\tlet j = 2;\n\t\t\t\t\t\tlet last = j;\n\t\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\t\tfor (; j < len; ++j) {\n\t\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\t\tconst firstPart = path.slice(last, j);\n\t\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t\t// Match 1 or more path separators\n\t\t\t\t\t\t\tfor (; j < len; ++j) {\n\t\t\t\t\t\t\t\tif (!isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\t\t\t\tfor (; j < len; ++j) {\n\t\t\t\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (j === len) {\n\t\t\t\t\t\t\t\t\t// We matched a UNC root only\n\n\t\t\t\t\t\t\t\t\tdevice = '\\\\\\\\' + firstPart + '\\\\' + path.slice(last);\n\t\t\t\t\t\t\t\t\trootEnd = j;\n\t\t\t\t\t\t\t\t} else if (j !== last) {\n\t\t\t\t\t\t\t\t\t// We matched a UNC root with leftovers\n\n\t\t\t\t\t\t\t\t\tdevice = '\\\\\\\\' + firstPart + '\\\\' + path.slice(last, j);\n\t\t\t\t\t\t\t\t\trootEnd = j;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\trootEnd = 1;\n\t\t\t\t\t}\n\t\t\t\t} else if (isWindowsDeviceRoot(code)) {\n\t\t\t\t\t// Possible device root\n\n\t\t\t\t\tif (path.charCodeAt(1) === CHAR_COLON) {\n\t\t\t\t\t\tdevice = path.slice(0, 2);\n\t\t\t\t\t\trootEnd = 2;\n\t\t\t\t\t\tif (len > 2) {\n\t\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\t\t\t\t\t// Treat separator following drive name as an absolute path\n\t\t\t\t\t\t\t\t// indicator\n\t\t\t\t\t\t\t\tisAbsolute = true;\n\t\t\t\t\t\t\t\trootEnd = 3;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (isPathSeparator(code)) {\n\t\t\t\t// `path` contains just a path separator\n\t\t\t\trootEnd = 1;\n\t\t\t\tisAbsolute = true;\n\t\t\t}\n\n\t\t\tif (device.length > 0 &&\n\t\t\t\tresolvedDevice.length > 0 &&\n\t\t\t\tdevice.toLowerCase() !== resolvedDevice.toLowerCase()) {\n\t\t\t\t// This path points to another device so it is not applicable\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (resolvedDevice.length === 0 && device.length > 0) {\n\t\t\t\tresolvedDevice = device;\n\t\t\t}\n\t\t\tif (!resolvedAbsolute) {\n\t\t\t\tresolvedTail = path.slice(rootEnd) + '\\\\' + resolvedTail;\n\t\t\t\tresolvedAbsolute = isAbsolute;\n\t\t\t}\n\n\t\t\tif (resolvedDevice.length > 0 && resolvedAbsolute) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// At this point the path should be resolved to a full absolute path,\n\t\t// but handle relative paths to be safe (might happen when process.cwd()\n\t\t// fails)\n\n\t\t// Normalize the tail path\n\t\tresolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, '\\\\',\n\t\t\tisPathSeparator);\n\n\t\treturn (resolvedDevice + (resolvedAbsolute ? '\\\\' : '') + resolvedTail) ||\n\t\t\t'.';\n\t},\n\n\tnormalize(path: string): string {\n\t\tvalidateString(path, 'path');\n\t\tconst len = path.length;\n\t\tif (len === 0) {\n\t\t\treturn '.';\n\t\t}\n\t\tlet rootEnd = 0;\n\t\tlet device;\n\t\tlet isAbsolute = false;\n\t\tconst code = path.charCodeAt(0);\n\n\t\t// Try to match a root\n\t\tif (len > 1) {\n\t\t\tif (isPathSeparator(code)) {\n\t\t\t\t// Possible UNC root\n\n\t\t\t\t// If we started with a separator, we know we at least have an absolute\n\t\t\t\t// path of some kind (UNC or otherwise)\n\t\t\t\tisAbsolute = true;\n\n\t\t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n\t\t\t\t\t// Matched double path separator at beginning\n\t\t\t\t\tlet j = 2;\n\t\t\t\t\tlet last = j;\n\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\tfor (; j < len; ++j) {\n\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\tconst firstPart = path.slice(last, j);\n\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t// Match 1 or more path separators\n\t\t\t\t\t\tfor (; j < len; ++j) {\n\t\t\t\t\t\t\tif (!isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\t\t\tfor (; j < len; ++j) {\n\t\t\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (j === len) {\n\t\t\t\t\t\t\t\t// We matched a UNC root only\n\t\t\t\t\t\t\t\t// Return the normalized version of the UNC root since there\n\t\t\t\t\t\t\t\t// is nothing left to process\n\n\t\t\t\t\t\t\t\treturn '\\\\\\\\' + firstPart + '\\\\' + path.slice(last) + '\\\\';\n\t\t\t\t\t\t\t} else if (j !== last) {\n\t\t\t\t\t\t\t\t// We matched a UNC root with leftovers\n\n\t\t\t\t\t\t\t\tdevice = '\\\\\\\\' + firstPart + '\\\\' + path.slice(last, j);\n\t\t\t\t\t\t\t\trootEnd = j;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\trootEnd = 1;\n\t\t\t\t}\n\t\t\t} else if (isWindowsDeviceRoot(code)) {\n\t\t\t\t// Possible device root\n\n\t\t\t\tif (path.charCodeAt(1) === CHAR_COLON) {\n\t\t\t\t\tdevice = path.slice(0, 2);\n\t\t\t\t\trootEnd = 2;\n\t\t\t\t\tif (len > 2) {\n\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\t\t\t\t// Treat separator following drive name as an absolute path\n\t\t\t\t\t\t\t// indicator\n\t\t\t\t\t\t\tisAbsolute = true;\n\t\t\t\t\t\t\trootEnd = 3;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (isPathSeparator(code)) {\n\t\t\t// `path` contains just a path separator, exit early to avoid unnecessary\n\t\t\t// work\n\t\t\treturn '\\\\';\n\t\t}\n\n\t\tlet tail;\n\t\tif (rootEnd < len) {\n\t\t\ttail = normalizeString(path.slice(rootEnd), !isAbsolute, '\\\\',\n\t\t\t\tisPathSeparator);\n\t\t} else {\n\t\t\ttail = '';\n\t\t}\n\t\tif (tail.length === 0 && !isAbsolute) {\n\t\t\ttail = '.';\n\t\t}\n\t\tif (tail.length > 0 && isPathSeparator(path.charCodeAt(len - 1))) {\n\t\t\ttail += '\\\\';\n\t\t}\n\t\tif (device === undefined) {\n\t\t\tif (isAbsolute) {\n\t\t\t\tif (tail.length > 0) {\n\t\t\t\t\treturn '\\\\' + tail;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn '\\\\';\n\t\t\t\t}\n\t\t\t} else if (tail.length > 0) {\n\t\t\t\treturn tail;\n\t\t\t} else {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t} else if (isAbsolute) {\n\t\t\tif (tail.length > 0) {\n\t\t\t\treturn device + '\\\\' + tail;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn device + '\\\\';\n\t\t\t}\n\t\t} else if (tail.length > 0) {\n\t\t\treturn device + tail;\n\t\t} else {\n\t\t\treturn device;\n\t\t}\n\t},\n\n\tisAbsolute(path: string): boolean {\n\t\tvalidateString(path, 'path');\n\t\tconst len = path.length;\n\t\tif (len === 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst code = path.charCodeAt(0);\n\t\tif (isPathSeparator(code)) {\n\t\t\treturn true;\n\t\t} else if (isWindowsDeviceRoot(code)) {\n\t\t\t// Possible device root\n\n\t\t\tif (len > 2 && path.charCodeAt(1) === CHAR_COLON) {\n\t\t\t\tif (isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t},\n\n\tjoin(...paths: string[]): string {\n\t\tif (paths.length === 0) {\n\t\t\treturn '.';\n\t\t}\n\n\t\tlet joined;\n\t\tlet firstPart: string | undefined;\n\t\tfor (let i = 0; i < paths.length; ++i) {\n\t\t\tconst arg = paths[i];\n\t\t\tvalidateString(arg, 'path');\n\t\t\tif (arg.length > 0) {\n\t\t\t\tif (joined === undefined) {\n\t\t\t\t\tjoined = firstPart = arg;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tjoined += '\\\\' + arg;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (joined === undefined) {\n\t\t\treturn '.';\n\t\t}\n\n\t\t// Make sure that the joined path doesn't start with two slashes, because\n\t\t// normalize() will mistake it for an UNC path then.\n\t\t//\n\t\t// This step is skipped when it is very clear that the user actually\n\t\t// intended to point at an UNC path. This is assumed when the first\n\t\t// non-empty string arguments starts with exactly two slashes followed by\n\t\t// at least one more non-slash character.\n\t\t//\n\t\t// Note that for normalize() to treat a path as an UNC path it needs to\n\t\t// have at least 2 components, so we don't filter for that here.\n\t\t// This means that the user can use join to construct UNC paths from\n\t\t// a server name and a share name; for example:\n\t\t//   path.join('//server', 'share') -> '\\\\\\\\server\\\\share\\\\')\n\t\tlet needsReplace = true;\n\t\tlet slashCount = 0;\n\t\tif (typeof firstPart === 'string' && isPathSeparator(firstPart.charCodeAt(0))) {\n\t\t\t++slashCount;\n\t\t\tconst firstLen = firstPart.length;\n\t\t\tif (firstLen > 1) {\n\t\t\t\tif (isPathSeparator(firstPart.charCodeAt(1))) {\n\t\t\t\t\t++slashCount;\n\t\t\t\t\tif (firstLen > 2) {\n\t\t\t\t\t\tif (isPathSeparator(firstPart.charCodeAt(2))) {\n\t\t\t\t\t\t\t++slashCount;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// We matched a UNC path in the first part\n\t\t\t\t\t\t\tneedsReplace = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (needsReplace) {\n\t\t\t// Find any more consecutive slashes we need to replace\n\t\t\tfor (; slashCount < joined.length; ++slashCount) {\n\t\t\t\tif (!isPathSeparator(joined.charCodeAt(slashCount))) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Replace the slashes if needed\n\t\t\tif (slashCount >= 2) {\n\t\t\t\tjoined = '\\\\' + joined.slice(slashCount);\n\t\t\t}\n\t\t}\n\n\t\treturn win32.normalize(joined);\n\t},\n\n\n\t// It will solve the relative path from `from` to `to`, for instance:\n\t//  from = 'C:\\\\orandea\\\\test\\\\aaa'\n\t//  to = 'C:\\\\orandea\\\\impl\\\\bbb'\n\t// The output of the function should be: '..\\\\..\\\\impl\\\\bbb'\n\trelative(from: string, to: string): string {\n\t\tvalidateString(from, 'from');\n\t\tvalidateString(to, 'to');\n\n\t\tif (from === to) {\n\t\t\treturn '';\n\t\t}\n\n\t\tconst fromOrig = win32.resolve(from);\n\t\tconst toOrig = win32.resolve(to);\n\n\t\tif (fromOrig === toOrig) {\n\t\t\treturn '';\n\t\t}\n\n\t\tfrom = fromOrig.toLowerCase();\n\t\tto = toOrig.toLowerCase();\n\n\t\tif (from === to) {\n\t\t\treturn '';\n\t\t}\n\n\t\t// Trim any leading backslashes\n\t\tlet fromStart = 0;\n\t\tfor (; fromStart < from.length; ++fromStart) {\n\t\t\tif (from.charCodeAt(fromStart) !== CHAR_BACKWARD_SLASH) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t// Trim trailing backslashes (applicable to UNC paths only)\n\t\tlet fromEnd = from.length;\n\t\tfor (; fromEnd - 1 > fromStart; --fromEnd) {\n\t\t\tif (from.charCodeAt(fromEnd - 1) !== CHAR_BACKWARD_SLASH) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tconst fromLen = (fromEnd - fromStart);\n\n\t\t// Trim any leading backslashes\n\t\tlet toStart = 0;\n\t\tfor (; toStart < to.length; ++toStart) {\n\t\t\tif (to.charCodeAt(toStart) !== CHAR_BACKWARD_SLASH) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t// Trim trailing backslashes (applicable to UNC paths only)\n\t\tlet toEnd = to.length;\n\t\tfor (; toEnd - 1 > toStart; --toEnd) {\n\t\t\tif (to.charCodeAt(toEnd - 1) !== CHAR_BACKWARD_SLASH) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tconst toLen = (toEnd - toStart);\n\n\t\t// Compare paths to find the longest common path from root\n\t\tconst length = (fromLen < toLen ? fromLen : toLen);\n\t\tlet lastCommonSep = -1;\n\t\tlet i = 0;\n\t\tfor (; i <= length; ++i) {\n\t\t\tif (i === length) {\n\t\t\t\tif (toLen > length) {\n\t\t\t\t\tif (to.charCodeAt(toStart + i) === CHAR_BACKWARD_SLASH) {\n\t\t\t\t\t\t// We get here if `from` is the exact base path for `to`.\n\t\t\t\t\t\t// For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo\\\\bar\\\\baz'\n\t\t\t\t\t\treturn toOrig.slice(toStart + i + 1);\n\t\t\t\t\t} else if (i === 2) {\n\t\t\t\t\t\t// We get here if `from` is the device root.\n\t\t\t\t\t\t// For example: from='C:\\\\'; to='C:\\\\foo'\n\t\t\t\t\t\treturn toOrig.slice(toStart + i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (fromLen > length) {\n\t\t\t\t\tif (from.charCodeAt(fromStart + i) === CHAR_BACKWARD_SLASH) {\n\t\t\t\t\t\t// We get here if `to` is the exact base path for `from`.\n\t\t\t\t\t\t// For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo'\n\t\t\t\t\t\tlastCommonSep = i;\n\t\t\t\t\t} else if (i === 2) {\n\t\t\t\t\t\t// We get here if `to` is the device root.\n\t\t\t\t\t\t// For example: from='C:\\\\foo\\\\bar'; to='C:\\\\'\n\t\t\t\t\t\tlastCommonSep = 3;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tconst fromCode = from.charCodeAt(fromStart + i);\n\t\t\tconst toCode = to.charCodeAt(toStart + i);\n\t\t\tif (fromCode !== toCode) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (fromCode === CHAR_BACKWARD_SLASH) {\n\t\t\t\tlastCommonSep = i;\n\t\t\t}\n\t\t}\n\n\t\t// We found a mismatch before the first common path separator was seen, so\n\t\t// return the original `to`.\n\t\tif (i !== length && lastCommonSep === -1) {\n\t\t\treturn toOrig;\n\t\t}\n\n\t\tlet out = '';\n\t\tif (lastCommonSep === -1) {\n\t\t\tlastCommonSep = 0;\n\t\t}\n\t\t// Generate the relative path based on the path difference between `to` and\n\t\t// `from`\n\t\tfor (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n\t\t\tif (i === fromEnd || from.charCodeAt(i) === CHAR_BACKWARD_SLASH) {\n\t\t\t\tif (out.length === 0) {\n\t\t\t\t\tout += '..';\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tout += '\\\\..';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Lastly, append the rest of the destination (`to`) path that comes after\n\t\t// the common path parts\n\t\tif (out.length > 0) {\n\t\t\treturn out + toOrig.slice(toStart + lastCommonSep, toEnd);\n\t\t}\n\t\telse {\n\t\t\ttoStart += lastCommonSep;\n\t\t\tif (toOrig.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {\n\t\t\t\t++toStart;\n\t\t\t}\n\t\t\treturn toOrig.slice(toStart, toEnd);\n\t\t}\n\t},\n\n\ttoNamespacedPath(path: string): string {\n\t\t// Note: this will *probably* throw somewhere.\n\t\tif (typeof path !== 'string') {\n\t\t\treturn path;\n\t\t}\n\n\t\tif (path.length === 0) {\n\t\t\treturn '';\n\t\t}\n\n\t\tconst resolvedPath = win32.resolve(path);\n\n\t\tif (resolvedPath.length >= 3) {\n\t\t\tif (resolvedPath.charCodeAt(0) === CHAR_BACKWARD_SLASH) {\n\t\t\t\t// Possible UNC root\n\n\t\t\t\tif (resolvedPath.charCodeAt(1) === CHAR_BACKWARD_SLASH) {\n\t\t\t\t\tconst code = resolvedPath.charCodeAt(2);\n\t\t\t\t\tif (code !== CHAR_QUESTION_MARK && code !== CHAR_DOT) {\n\t\t\t\t\t\t// Matched non-long UNC root, convert the path to a long UNC path\n\t\t\t\t\t\treturn '\\\\\\\\?\\\\UNC\\\\' + resolvedPath.slice(2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0))) {\n\t\t\t\t// Possible device root\n\n\t\t\t\tif (resolvedPath.charCodeAt(1) === CHAR_COLON &&\n\t\t\t\t\tresolvedPath.charCodeAt(2) === CHAR_BACKWARD_SLASH) {\n\t\t\t\t\t// Matched device root, convert the path to a long UNC path\n\t\t\t\t\treturn '\\\\\\\\?\\\\' + resolvedPath;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn path;\n\t},\n\n\tdirname(path: string): string {\n\t\tvalidateString(path, 'path');\n\t\tconst len = path.length;\n\t\tif (len === 0) {\n\t\t\treturn '.';\n\t\t}\n\t\tlet rootEnd = -1;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\tlet offset = 0;\n\t\tconst code = path.charCodeAt(0);\n\n\t\t// Try to match a root\n\t\tif (len > 1) {\n\t\t\tif (isPathSeparator(code)) {\n\t\t\t\t// Possible UNC root\n\n\t\t\t\trootEnd = offset = 1;\n\n\t\t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n\t\t\t\t\t// Matched double path separator at beginning\n\t\t\t\t\tlet j = 2;\n\t\t\t\t\tlet last = j;\n\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\tfor (; j < len; ++j) {\n\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t// Match 1 or more path separators\n\t\t\t\t\t\tfor (; j < len; ++j) {\n\t\t\t\t\t\t\tif (!isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\t\t\tfor (; j < len; ++j) {\n\t\t\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (j === len) {\n\t\t\t\t\t\t\t\t// We matched a UNC root only\n\t\t\t\t\t\t\t\treturn path;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (j !== last) {\n\t\t\t\t\t\t\t\t// We matched a UNC root with leftovers\n\n\t\t\t\t\t\t\t\t// Offset by 1 to include the separator after the UNC root to\n\t\t\t\t\t\t\t\t// treat it as a \"normal root\" on top of a (UNC) root\n\t\t\t\t\t\t\t\trootEnd = offset = j + 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (isWindowsDeviceRoot(code)) {\n\t\t\t\t// Possible device root\n\n\t\t\t\tif (path.charCodeAt(1) === CHAR_COLON) {\n\t\t\t\t\trootEnd = offset = 2;\n\t\t\t\t\tif (len > 2) {\n\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\t\t\t\trootEnd = offset = 3;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (isPathSeparator(code)) {\n\t\t\t// `path` contains just a path separator, exit early to avoid\n\t\t\t// unnecessary work\n\t\t\treturn path;\n\t\t}\n\n\t\tfor (let i = len - 1; i >= offset; --i) {\n\t\t\tif (isPathSeparator(path.charCodeAt(i))) {\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tend = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// We saw the first non-path separator\n\t\t\t\tmatchedSlash = false;\n\t\t\t}\n\t\t}\n\n\t\tif (end === -1) {\n\t\t\tif (rootEnd === -1) {\n\t\t\t\treturn '.';\n\t\t\t}\n\t\t\telse {\n\t\t\t\tend = rootEnd;\n\t\t\t}\n\t\t}\n\t\treturn path.slice(0, end);\n\t},\n\n\tbasename(path: string, ext?: string): string {\n\t\tif (ext !== undefined) {\n\t\t\tvalidateString(ext, 'ext');\n\t\t}\n\t\tvalidateString(path, 'path');\n\t\tlet start = 0;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\tlet i;\n\n\t\t// Check for a drive letter prefix so as not to mistake the following\n\t\t// path separator as an extra separator at the end of the path that can be\n\t\t// disregarded\n\t\tif (path.length >= 2) {\n\t\t\tconst drive = path.charCodeAt(0);\n\t\t\tif (isWindowsDeviceRoot(drive)) {\n\t\t\t\tif (path.charCodeAt(1) === CHAR_COLON) {\n\t\t\t\t\tstart = 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n\t\t\tif (ext.length === path.length && ext === path) {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t\tlet extIdx = ext.length - 1;\n\t\t\tlet firstNonSlashEnd = -1;\n\t\t\tfor (i = path.length - 1; i >= start; --i) {\n\t\t\t\tconst code = path.charCodeAt(i);\n\t\t\t\tif (isPathSeparator(code)) {\n\t\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\t\tstart = i + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (firstNonSlashEnd === -1) {\n\t\t\t\t\t\t// We saw the first non-path separator, remember this index in case\n\t\t\t\t\t\t// we need it if the extension ends up not matching\n\t\t\t\t\t\tmatchedSlash = false;\n\t\t\t\t\t\tfirstNonSlashEnd = i + 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (extIdx >= 0) {\n\t\t\t\t\t\t// Try to match the explicit extension\n\t\t\t\t\t\tif (code === ext.charCodeAt(extIdx)) {\n\t\t\t\t\t\t\tif (--extIdx === -1) {\n\t\t\t\t\t\t\t\t// We matched the extension, so mark this as the end of our path\n\t\t\t\t\t\t\t\t// component\n\t\t\t\t\t\t\t\tend = i;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Extension does not match, so our result is the entire path\n\t\t\t\t\t\t\t// component\n\t\t\t\t\t\t\textIdx = -1;\n\t\t\t\t\t\t\tend = firstNonSlashEnd;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (start === end) {\n\t\t\t\tend = firstNonSlashEnd;\n\t\t\t}\n\t\t\telse if (end === -1) {\n\t\t\t\tend = path.length;\n\t\t\t}\n\t\t\treturn path.slice(start, end);\n\t\t} else {\n\t\t\tfor (i = path.length - 1; i >= start; --i) {\n\t\t\t\tif (isPathSeparator(path.charCodeAt(i))) {\n\t\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\t\tstart = i + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else if (end === -1) {\n\t\t\t\t\t// We saw the first non-path separator, mark this as the end of our\n\t\t\t\t\t// path component\n\t\t\t\t\tmatchedSlash = false;\n\t\t\t\t\tend = i + 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (end === -1) {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t\treturn path.slice(start, end);\n\t\t}\n\t},\n\n\textname(path: string): string {\n\t\tvalidateString(path, 'path');\n\t\tlet start = 0;\n\t\tlet startDot = -1;\n\t\tlet startPart = 0;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\t// Track the state of characters (if any) we see before our first dot and\n\t\t// after any path separator we find\n\t\tlet preDotState = 0;\n\n\t\t// Check for a drive letter prefix so as not to mistake the following\n\t\t// path separator as an extra separator at the end of the path that can be\n\t\t// disregarded\n\n\t\tif (path.length >= 2 &&\n\t\t\tpath.charCodeAt(1) === CHAR_COLON &&\n\t\t\tisWindowsDeviceRoot(path.charCodeAt(0))) {\n\t\t\tstart = startPart = 2;\n\t\t}\n\n\t\tfor (let i = path.length - 1; i >= start; --i) {\n\t\t\tconst code = path.charCodeAt(i);\n\t\t\tif (isPathSeparator(code)) {\n\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tstartPart = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (end === -1) {\n\t\t\t\t// We saw the first non-path separator, mark this as the end of our\n\t\t\t\t// extension\n\t\t\t\tmatchedSlash = false;\n\t\t\t\tend = i + 1;\n\t\t\t}\n\t\t\tif (code === CHAR_DOT) {\n\t\t\t\t// If this is our first dot, mark it as the start of our extension\n\t\t\t\tif (startDot === -1) {\n\t\t\t\t\tstartDot = i;\n\t\t\t\t}\n\t\t\t\telse if (preDotState !== 1) {\n\t\t\t\t\tpreDotState = 1;\n\t\t\t\t}\n\t\t\t} else if (startDot !== -1) {\n\t\t\t\t// We saw a non-dot and non-path separator before our dot, so we should\n\t\t\t\t// have a good chance at having a non-empty extension\n\t\t\t\tpreDotState = -1;\n\t\t\t}\n\t\t}\n\n\t\tif (startDot === -1 ||\n\t\t\tend === -1 ||\n\t\t\t// We saw a non-dot character immediately before the dot\n\t\t\tpreDotState === 0 ||\n\t\t\t// The (right-most) trimmed path component is exactly '..'\n\t\t\t(preDotState === 1 &&\n\t\t\t\tstartDot === end - 1 &&\n\t\t\t\tstartDot === startPart + 1)) {\n\t\t\treturn '';\n\t\t}\n\t\treturn path.slice(startDot, end);\n\t},\n\n\tformat(pathObject): string {\n\t\tif (pathObject === null || typeof pathObject !== 'object') {\n\t\t\tthrow new ErrorInvalidArgType('pathObject', 'Object', pathObject);\n\t\t}\n\n\t\treturn _format('\\\\', pathObject);\n\t},\n\n\n\tparse(path) {\n\t\tvalidateString(path, 'path');\n\n\t\tconst ret = { root: '', dir: '', base: '', ext: '', name: '' };\n\t\tif (path.length === 0) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tconst len = path.length;\n\t\tlet rootEnd = 0;\n\t\tlet code = path.charCodeAt(0);\n\n\t\t// Try to match a root\n\t\tif (len > 1) {\n\t\t\tif (isPathSeparator(code)) {\n\t\t\t\t// Possible UNC root\n\n\t\t\t\trootEnd = 1;\n\t\t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n\t\t\t\t\t// Matched double path separator at beginning\n\t\t\t\t\tlet j = 2;\n\t\t\t\t\tlet last = j;\n\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\tfor (; j < len; ++j) {\n\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t// Match 1 or more path separators\n\t\t\t\t\t\tfor (; j < len; ++j) {\n\t\t\t\t\t\t\tif (!isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\t\t\tfor (; j < len; ++j) {\n\t\t\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (j === len) {\n\t\t\t\t\t\t\t\t// We matched a UNC root only\n\n\t\t\t\t\t\t\t\trootEnd = j;\n\t\t\t\t\t\t\t} else if (j !== last) {\n\t\t\t\t\t\t\t\t// We matched a UNC root with leftovers\n\n\t\t\t\t\t\t\t\trootEnd = j + 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (isWindowsDeviceRoot(code)) {\n\t\t\t\t// Possible device root\n\n\t\t\t\tif (path.charCodeAt(1) === CHAR_COLON) {\n\t\t\t\t\trootEnd = 2;\n\t\t\t\t\tif (len > 2) {\n\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\t\t\t\tif (len === 3) {\n\t\t\t\t\t\t\t\t// `path` contains just a drive root, exit early to avoid\n\t\t\t\t\t\t\t\t// unnecessary work\n\t\t\t\t\t\t\t\tret.root = ret.dir = path;\n\t\t\t\t\t\t\t\treturn ret;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\trootEnd = 3;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// `path` contains just a drive root, exit early to avoid\n\t\t\t\t\t\t// unnecessary work\n\t\t\t\t\t\tret.root = ret.dir = path;\n\t\t\t\t\t\treturn ret;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (isPathSeparator(code)) {\n\t\t\t// `path` contains just a path separator, exit early to avoid\n\t\t\t// unnecessary work\n\t\t\tret.root = ret.dir = path;\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (rootEnd > 0) {\n\t\t\tret.root = path.slice(0, rootEnd);\n\t\t}\n\n\t\tlet startDot = -1;\n\t\tlet startPart = rootEnd;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\tlet i = path.length - 1;\n\n\t\t// Track the state of characters (if any) we see before our first dot and\n\t\t// after any path separator we find\n\t\tlet preDotState = 0;\n\n\t\t// Get non-dir info\n\t\tfor (; i >= rootEnd; --i) {\n\t\t\tcode = path.charCodeAt(i);\n\t\t\tif (isPathSeparator(code)) {\n\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tstartPart = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (end === -1) {\n\t\t\t\t// We saw the first non-path separator, mark this as the end of our\n\t\t\t\t// extension\n\t\t\t\tmatchedSlash = false;\n\t\t\t\tend = i + 1;\n\t\t\t}\n\t\t\tif (code === CHAR_DOT) {\n\t\t\t\t// If this is our first dot, mark it as the start of our extension\n\t\t\t\tif (startDot === -1) {\n\t\t\t\t\tstartDot = i;\n\t\t\t\t}\n\t\t\t\telse if (preDotState !== 1) {\n\t\t\t\t\tpreDotState = 1;\n\t\t\t\t}\n\t\t\t} else if (startDot !== -1) {\n\t\t\t\t// We saw a non-dot and non-path separator before our dot, so we should\n\t\t\t\t// have a good chance at having a non-empty extension\n\t\t\t\tpreDotState = -1;\n\t\t\t}\n\t\t}\n\n\t\tif (startDot === -1 ||\n\t\t\tend === -1 ||\n\t\t\t// We saw a non-dot character immediately before the dot\n\t\t\tpreDotState === 0 ||\n\t\t\t// The (right-most) trimmed path component is exactly '..'\n\t\t\t(preDotState === 1 &&\n\t\t\t\tstartDot === end - 1 &&\n\t\t\t\tstartDot === startPart + 1)) {\n\t\t\tif (end !== -1) {\n\t\t\t\tret.base = ret.name = path.slice(startPart, end);\n\t\t\t}\n\t\t} else {\n\t\t\tret.name = path.slice(startPart, startDot);\n\t\t\tret.base = path.slice(startPart, end);\n\t\t\tret.ext = path.slice(startDot, end);\n\t\t}\n\n\t\t// If the directory is the root, use the entire root as the `dir` including\n\t\t// the trailing slash if any (`C:\\abc` -> `C:\\`). Otherwise, strip out the\n\t\t// trailing slash (`C:\\abc\\def` -> `C:\\abc`).\n\t\tif (startPart > 0 && startPart !== rootEnd) {\n\t\t\tret.dir = path.slice(0, startPart - 1);\n\t\t}\n\t\telse {\n\t\t\tret.dir = ret.root;\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\tsep: '\\\\',\n\tdelimiter: ';',\n\twin32: null,\n\tposix: null\n};\n\nexport const posix: IPath = {\n\t// path.resolve([from ...], to)\n\tresolve(...pathSegments: string[]): string {\n\t\tlet resolvedPath = '';\n\t\tlet resolvedAbsolute = false;\n\n\t\tfor (let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n\t\t\tlet path;\n\t\t\tif (i >= 0) {\n\t\t\t\tpath = pathSegments[i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpath = process.cwd();\n\t\t\t}\n\n\t\t\tvalidateString(path, 'path');\n\n\t\t\t// Skip empty entries\n\t\t\tif (path.length === 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tresolvedPath = path + '/' + resolvedPath;\n\t\t\tresolvedAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n\t\t}\n\n\t\t// At this point the path should be resolved to a full absolute path, but\n\t\t// handle relative paths to be safe (might happen when process.cwd() fails)\n\n\t\t// Normalize the path\n\t\tresolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, '/',\n\t\t\tisPosixPathSeparator);\n\n\t\tif (resolvedAbsolute) {\n\t\t\tif (resolvedPath.length > 0) {\n\t\t\t\treturn '/' + resolvedPath;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn '/';\n\t\t\t}\n\t\t} else if (resolvedPath.length > 0) {\n\t\t\treturn resolvedPath;\n\t\t} else {\n\t\t\treturn '.';\n\t\t}\n\t},\n\n\tnormalize(path: string): string {\n\t\tvalidateString(path, 'path');\n\n\t\tif (path.length === 0) {\n\t\t\treturn '.';\n\t\t}\n\n\t\tconst isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n\t\tconst trailingSeparator =\n\t\t\tpath.charCodeAt(path.length - 1) === CHAR_FORWARD_SLASH;\n\n\t\t// Normalize the path\n\t\tpath = normalizeString(path, !isAbsolute, '/', isPosixPathSeparator);\n\n\t\tif (path.length === 0 && !isAbsolute) {\n\t\t\tpath = '.';\n\t\t}\n\t\tif (path.length > 0 && trailingSeparator) {\n\t\t\tpath += '/';\n\t\t}\n\n\t\tif (isAbsolute) {\n\t\t\treturn '/' + path;\n\t\t}\n\t\treturn path;\n\t},\n\n\tisAbsolute(path: string): boolean {\n\t\tvalidateString(path, 'path');\n\t\treturn path.length > 0 && path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n\t},\n\n\tjoin(...paths: string[]): string {\n\t\tif (paths.length === 0) {\n\t\t\treturn '.';\n\t\t}\n\t\tlet joined;\n\t\tfor (let i = 0; i < paths.length; ++i) {\n\t\t\tconst arg = arguments[i];\n\t\t\tvalidateString(arg, 'path');\n\t\t\tif (arg.length > 0) {\n\t\t\t\tif (joined === undefined) {\n\t\t\t\t\tjoined = arg;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tjoined += '/' + arg;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (joined === undefined) {\n\t\t\treturn '.';\n\t\t}\n\t\treturn posix.normalize(joined);\n\t},\n\n\trelative(from: string, to: string): string {\n\t\tvalidateString(from, 'from');\n\t\tvalidateString(to, 'to');\n\n\t\tif (from === to) {\n\t\t\treturn '';\n\t\t}\n\n\t\tfrom = posix.resolve(from);\n\t\tto = posix.resolve(to);\n\n\t\tif (from === to) {\n\t\t\treturn '';\n\t\t}\n\n\t\t// Trim any leading backslashes\n\t\tlet fromStart = 1;\n\t\tfor (; fromStart < from.length; ++fromStart) {\n\t\t\tif (from.charCodeAt(fromStart) !== CHAR_FORWARD_SLASH) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tconst fromEnd = from.length;\n\t\tconst fromLen = (fromEnd - fromStart);\n\n\t\t// Trim any leading backslashes\n\t\tlet toStart = 1;\n\t\tfor (; toStart < to.length; ++toStart) {\n\t\t\tif (to.charCodeAt(toStart) !== CHAR_FORWARD_SLASH) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tconst toEnd = to.length;\n\t\tconst toLen = (toEnd - toStart);\n\n\t\t// Compare paths to find the longest common path from root\n\t\tconst length = (fromLen < toLen ? fromLen : toLen);\n\t\tlet lastCommonSep = -1;\n\t\tlet i = 0;\n\t\tfor (; i <= length; ++i) {\n\t\t\tif (i === length) {\n\t\t\t\tif (toLen > length) {\n\t\t\t\t\tif (to.charCodeAt(toStart + i) === CHAR_FORWARD_SLASH) {\n\t\t\t\t\t\t// We get here if `from` is the exact base path for `to`.\n\t\t\t\t\t\t// For example: from='/foo/bar'; to='/foo/bar/baz'\n\t\t\t\t\t\treturn to.slice(toStart + i + 1);\n\t\t\t\t\t} else if (i === 0) {\n\t\t\t\t\t\t// We get here if `from` is the root\n\t\t\t\t\t\t// For example: from='/'; to='/foo'\n\t\t\t\t\t\treturn to.slice(toStart + i);\n\t\t\t\t\t}\n\t\t\t\t} else if (fromLen > length) {\n\t\t\t\t\tif (from.charCodeAt(fromStart + i) === CHAR_FORWARD_SLASH) {\n\t\t\t\t\t\t// We get here if `to` is the exact base path for `from`.\n\t\t\t\t\t\t// For example: from='/foo/bar/baz'; to='/foo/bar'\n\t\t\t\t\t\tlastCommonSep = i;\n\t\t\t\t\t} else if (i === 0) {\n\t\t\t\t\t\t// We get here if `to` is the root.\n\t\t\t\t\t\t// For example: from='/foo'; to='/'\n\t\t\t\t\t\tlastCommonSep = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tconst fromCode = from.charCodeAt(fromStart + i);\n\t\t\tconst toCode = to.charCodeAt(toStart + i);\n\t\t\tif (fromCode !== toCode) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (fromCode === CHAR_FORWARD_SLASH) {\n\t\t\t\tlastCommonSep = i;\n\t\t\t}\n\t\t}\n\n\t\tlet out = '';\n\t\t// Generate the relative path based on the path difference between `to`\n\t\t// and `from`\n\t\tfor (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n\t\t\tif (i === fromEnd || from.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n\t\t\t\tif (out.length === 0) {\n\t\t\t\t\tout += '..';\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tout += '/..';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Lastly, append the rest of the destination (`to`) path that comes after\n\t\t// the common path parts\n\t\tif (out.length > 0) {\n\t\t\treturn out + to.slice(toStart + lastCommonSep);\n\t\t}\n\t\telse {\n\t\t\ttoStart += lastCommonSep;\n\t\t\tif (to.charCodeAt(toStart) === CHAR_FORWARD_SLASH) {\n\t\t\t\t++toStart;\n\t\t\t}\n\t\t\treturn to.slice(toStart);\n\t\t}\n\t},\n\n\ttoNamespacedPath(path: string): string {\n\t\t// Non-op on posix systems\n\t\treturn path;\n\t},\n\n\tdirname(path: string): string {\n\t\tvalidateString(path, 'path');\n\t\tif (path.length === 0) {\n\t\t\treturn '.';\n\t\t}\n\t\tconst hasRoot = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\tfor (let i = path.length - 1; i >= 1; --i) {\n\t\t\tif (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tend = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// We saw the first non-path separator\n\t\t\t\tmatchedSlash = false;\n\t\t\t}\n\t\t}\n\n\t\tif (end === -1) {\n\t\t\treturn hasRoot ? '/' : '.';\n\t\t}\n\t\tif (hasRoot && end === 1) {\n\t\t\treturn '//';\n\t\t}\n\t\treturn path.slice(0, end);\n\t},\n\n\tbasename(path: string, ext?: string): string {\n\t\tif (ext !== undefined) {\n\t\t\tvalidateString(ext, 'ext');\n\t\t}\n\t\tvalidateString(path, 'path');\n\n\t\tlet start = 0;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\tlet i;\n\n\t\tif (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n\t\t\tif (ext.length === path.length && ext === path) {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t\tlet extIdx = ext.length - 1;\n\t\t\tlet firstNonSlashEnd = -1;\n\t\t\tfor (i = path.length - 1; i >= 0; --i) {\n\t\t\t\tconst code = path.charCodeAt(i);\n\t\t\t\tif (code === CHAR_FORWARD_SLASH) {\n\t\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\t\tstart = i + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (firstNonSlashEnd === -1) {\n\t\t\t\t\t\t// We saw the first non-path separator, remember this index in case\n\t\t\t\t\t\t// we need it if the extension ends up not matching\n\t\t\t\t\t\tmatchedSlash = false;\n\t\t\t\t\t\tfirstNonSlashEnd = i + 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (extIdx >= 0) {\n\t\t\t\t\t\t// Try to match the explicit extension\n\t\t\t\t\t\tif (code === ext.charCodeAt(extIdx)) {\n\t\t\t\t\t\t\tif (--extIdx === -1) {\n\t\t\t\t\t\t\t\t// We matched the extension, so mark this as the end of our path\n\t\t\t\t\t\t\t\t// component\n\t\t\t\t\t\t\t\tend = i;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Extension does not match, so our result is the entire path\n\t\t\t\t\t\t\t// component\n\t\t\t\t\t\t\textIdx = -1;\n\t\t\t\t\t\t\tend = firstNonSlashEnd;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (start === end) {\n\t\t\t\tend = firstNonSlashEnd;\n\t\t\t}\n\t\t\telse if (end === -1) {\n\t\t\t\tend = path.length;\n\t\t\t}\n\t\t\treturn path.slice(start, end);\n\t\t} else {\n\t\t\tfor (i = path.length - 1; i >= 0; --i) {\n\t\t\t\tif (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n\t\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\t\tstart = i + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else if (end === -1) {\n\t\t\t\t\t// We saw the first non-path separator, mark this as the end of our\n\t\t\t\t\t// path component\n\t\t\t\t\tmatchedSlash = false;\n\t\t\t\t\tend = i + 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (end === -1) {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t\treturn path.slice(start, end);\n\t\t}\n\t},\n\n\textname(path: string): string {\n\t\tvalidateString(path, 'path');\n\t\tlet startDot = -1;\n\t\tlet startPart = 0;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\t// Track the state of characters (if any) we see before our first dot and\n\t\t// after any path separator we find\n\t\tlet preDotState = 0;\n\t\tfor (let i = path.length - 1; i >= 0; --i) {\n\t\t\tconst code = path.charCodeAt(i);\n\t\t\tif (code === CHAR_FORWARD_SLASH) {\n\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tstartPart = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (end === -1) {\n\t\t\t\t// We saw the first non-path separator, mark this as the end of our\n\t\t\t\t// extension\n\t\t\t\tmatchedSlash = false;\n\t\t\t\tend = i + 1;\n\t\t\t}\n\t\t\tif (code === CHAR_DOT) {\n\t\t\t\t// If this is our first dot, mark it as the start of our extension\n\t\t\t\tif (startDot === -1) {\n\t\t\t\t\tstartDot = i;\n\t\t\t\t}\n\t\t\t\telse if (preDotState !== 1) {\n\t\t\t\t\tpreDotState = 1;\n\t\t\t\t}\n\t\t\t} else if (startDot !== -1) {\n\t\t\t\t// We saw a non-dot and non-path separator before our dot, so we should\n\t\t\t\t// have a good chance at having a non-empty extension\n\t\t\t\tpreDotState = -1;\n\t\t\t}\n\t\t}\n\n\t\tif (startDot === -1 ||\n\t\t\tend === -1 ||\n\t\t\t// We saw a non-dot character immediately before the dot\n\t\t\tpreDotState === 0 ||\n\t\t\t// The (right-most) trimmed path component is exactly '..'\n\t\t\t(preDotState === 1 &&\n\t\t\t\tstartDot === end - 1 &&\n\t\t\t\tstartDot === startPart + 1)) {\n\t\t\treturn '';\n\t\t}\n\t\treturn path.slice(startDot, end);\n\t},\n\n\tformat(pathObject): string {\n\t\tif (pathObject === null || typeof pathObject !== 'object') {\n\t\t\tthrow new ErrorInvalidArgType('pathObject', 'Object', pathObject);\n\t\t}\n\n\t\treturn _format('/', pathObject);\n\t},\n\n\tparse(path: string): ParsedPath {\n\t\tvalidateString(path, 'path');\n\n\t\tconst ret = { root: '', dir: '', base: '', ext: '', name: '' };\n\t\tif (path.length === 0) {\n\t\t\treturn ret;\n\t\t}\n\t\tconst isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n\t\tlet start;\n\t\tif (isAbsolute) {\n\t\t\tret.root = '/';\n\t\t\tstart = 1;\n\t\t} else {\n\t\t\tstart = 0;\n\t\t}\n\t\tlet startDot = -1;\n\t\tlet startPart = 0;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\tlet i = path.length - 1;\n\n\t\t// Track the state of characters (if any) we see before our first dot and\n\t\t// after any path separator we find\n\t\tlet preDotState = 0;\n\n\t\t// Get non-dir info\n\t\tfor (; i >= start; --i) {\n\t\t\tconst code = path.charCodeAt(i);\n\t\t\tif (code === CHAR_FORWARD_SLASH) {\n\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tstartPart = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (end === -1) {\n\t\t\t\t// We saw the first non-path separator, mark this as the end of our\n\t\t\t\t// extension\n\t\t\t\tmatchedSlash = false;\n\t\t\t\tend = i + 1;\n\t\t\t}\n\t\t\tif (code === CHAR_DOT) {\n\t\t\t\t// If this is our first dot, mark it as the start of our extension\n\t\t\t\tif (startDot === -1) {\n\t\t\t\t\tstartDot = i;\n\t\t\t\t}\n\t\t\t\telse if (preDotState !== 1) {\n\t\t\t\t\tpreDotState = 1;\n\t\t\t\t}\n\t\t\t} else if (startDot !== -1) {\n\t\t\t\t// We saw a non-dot and non-path separator before our dot, so we should\n\t\t\t\t// have a good chance at having a non-empty extension\n\t\t\t\tpreDotState = -1;\n\t\t\t}\n\t\t}\n\n\t\tif (startDot === -1 ||\n\t\t\tend === -1 ||\n\t\t\t// We saw a non-dot character immediately before the dot\n\t\t\tpreDotState === 0 ||\n\t\t\t// The (right-most) trimmed path component is exactly '..'\n\t\t\t(preDotState === 1 &&\n\t\t\t\tstartDot === end - 1 &&\n\t\t\t\tstartDot === startPart + 1)) {\n\t\t\tif (end !== -1) {\n\t\t\t\tif (startPart === 0 && isAbsolute) {\n\t\t\t\t\tret.base = ret.name = path.slice(1, end);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tret.base = ret.name = path.slice(startPart, end);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (startPart === 0 && isAbsolute) {\n\t\t\t\tret.name = path.slice(1, startDot);\n\t\t\t\tret.base = path.slice(1, end);\n\t\t\t} else {\n\t\t\t\tret.name = path.slice(startPart, startDot);\n\t\t\t\tret.base = path.slice(startPart, end);\n\t\t\t}\n\t\t\tret.ext = path.slice(startDot, end);\n\t\t}\n\n\t\tif (startPart > 0) {\n\t\t\tret.dir = path.slice(0, startPart - 1);\n\t\t}\n\t\telse if (isAbsolute) {\n\t\t\tret.dir = '/';\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\tsep: '/',\n\tdelimiter: ':',\n\twin32: null,\n\tposix: null\n};\n\nposix.win32 = win32.win32 = win32;\nposix.posix = win32.posix = posix;\n\nexport const normalize = (process.platform === 'win32' ? win32.normalize : posix.normalize);\nexport const isAbsolute = (process.platform === 'win32' ? win32.isAbsolute : posix.isAbsolute);\nexport const join = (process.platform === 'win32' ? win32.join : posix.join);\nexport const resolve = (process.platform === 'win32' ? win32.resolve : posix.resolve);\nexport const relative = (process.platform === 'win32' ? win32.relative : posix.relative);\nexport const dirname = (process.platform === 'win32' ? win32.dirname : posix.dirname);\nexport const basename = (process.platform === 'win32' ? win32.basename : posix.basename);\nexport const extname = (process.platform === 'win32' ? win32.extname : posix.extname);\nexport const format = (process.platform === 'win32' ? win32.format : posix.format);\nexport const parse = (process.platform === 'win32' ? win32.parse : posix.parse);\nexport const toNamespacedPath = (process.platform === 'win32' ? win32.toNamespacedPath : posix.toNamespacedPath);\nexport const sep = (process.platform === 'win32' ? win32.sep : posix.sep);\nexport const delimiter = (process.platform === 'win32' ? win32.delimiter : posix.delimiter);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { isWindows } from 'vs/base/common/platform';\nimport { startsWithIgnoreCase, equalsIgnoreCase, endsWith, rtrim } from 'vs/base/common/strings';\nimport { CharCode } from 'vs/base/common/charCode';\nimport { sep, posix, isAbsolute, join, normalize } from 'vs/base/common/path';\n\nexport function isPathSeparator(code: number) {\n\treturn code === CharCode.Slash || code === CharCode.Backslash;\n}\n\n/**\n * Takes a Windows OS path and changes backward slashes to forward slashes.\n * This should only be done for OS paths from Windows (or user provided paths potentially from Windows).\n * Using it on a Linux or MaxOS path might change it.\n */\nexport function toSlashes(osPath: string) {\n\treturn osPath.replace(/[\\\\/]/g, posix.sep);\n}\n\n/**\n * Computes the _root_ this path, like `getRoot('c:\\files') === c:\\`,\n * `getRoot('files:///files/path') === files:///`,\n * or `getRoot('\\\\server\\shares\\path') === \\\\server\\shares\\`\n */\nexport function getRoot(path: string, sep: string = posix.sep): string {\n\n\tif (!path) {\n\t\treturn '';\n\t}\n\n\tconst len = path.length;\n\tconst firstLetter = path.charCodeAt(0);\n\tif (isPathSeparator(firstLetter)) {\n\t\tif (isPathSeparator(path.charCodeAt(1))) {\n\t\t\t// UNC candidate \\\\localhost\\shares\\ddd\n\t\t\t//               ^^^^^^^^^^^^^^^^^^^\n\t\t\tif (!isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\tlet pos = 3;\n\t\t\t\tconst start = pos;\n\t\t\t\tfor (; pos < len; pos++) {\n\t\t\t\t\tif (isPathSeparator(path.charCodeAt(pos))) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (start !== pos && !isPathSeparator(path.charCodeAt(pos + 1))) {\n\t\t\t\t\tpos += 1;\n\t\t\t\t\tfor (; pos < len; pos++) {\n\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(pos))) {\n\t\t\t\t\t\t\treturn path.slice(0, pos + 1) // consume this separator\n\t\t\t\t\t\t\t\t.replace(/[\\\\/]/g, sep);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// /user/far\n\t\t// ^\n\t\treturn sep;\n\n\t} else if (isWindowsDriveLetter(firstLetter)) {\n\t\t// check for windows drive letter c:\\ or c:\n\n\t\tif (path.charCodeAt(1) === CharCode.Colon) {\n\t\t\tif (isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\t// C:\\fff\n\t\t\t\t// ^^^\n\t\t\t\treturn path.slice(0, 2) + sep;\n\t\t\t} else {\n\t\t\t\t// C:\n\t\t\t\t// ^^\n\t\t\t\treturn path.slice(0, 2);\n\t\t\t}\n\t\t}\n\t}\n\n\t// check for URI\n\t// scheme://authority/path\n\t// ^^^^^^^^^^^^^^^^^^^\n\tlet pos = path.indexOf('://');\n\tif (pos !== -1) {\n\t\tpos += 3; // 3 -> \"://\".length\n\t\tfor (; pos < len; pos++) {\n\t\t\tif (isPathSeparator(path.charCodeAt(pos))) {\n\t\t\t\treturn path.slice(0, pos + 1); // consume this separator\n\t\t\t}\n\t\t}\n\t}\n\n\treturn '';\n}\n\n/**\n * Check if the path follows this pattern: `\\\\hostname\\sharename`.\n *\n * @see https://msdn.microsoft.com/en-us/library/gg465305.aspx\n * @return A boolean indication if the path is a UNC path, on none-windows\n * always false.\n */\nexport function isUNC(path: string): boolean {\n\tif (!isWindows) {\n\t\t// UNC is a windows concept\n\t\treturn false;\n\t}\n\n\tif (!path || path.length < 5) {\n\t\t// at least \\\\a\\b\n\t\treturn false;\n\t}\n\n\tlet code = path.charCodeAt(0);\n\tif (code !== CharCode.Backslash) {\n\t\treturn false;\n\t}\n\tcode = path.charCodeAt(1);\n\tif (code !== CharCode.Backslash) {\n\t\treturn false;\n\t}\n\tlet pos = 2;\n\tconst start = pos;\n\tfor (; pos < path.length; pos++) {\n\t\tcode = path.charCodeAt(pos);\n\t\tif (code === CharCode.Backslash) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (start === pos) {\n\t\treturn false;\n\t}\n\tcode = path.charCodeAt(pos + 1);\n\tif (isNaN(code) || code === CharCode.Backslash) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\n// Reference: https://en.wikipedia.org/wiki/Filename\nconst WINDOWS_INVALID_FILE_CHARS = /[\\\\/:\\*\\?\"<>\\|]/g;\nconst UNIX_INVALID_FILE_CHARS = /[\\\\/]/g;\nconst WINDOWS_FORBIDDEN_NAMES = /^(con|prn|aux|clock\\$|nul|lpt[0-9]|com[0-9])$/i;\nexport function isValidBasename(name: string | null | undefined, isWindowsOS: boolean = isWindows): boolean {\n\tconst invalidFileChars = isWindowsOS ? WINDOWS_INVALID_FILE_CHARS : UNIX_INVALID_FILE_CHARS;\n\n\tif (!name || name.length === 0 || /^\\s+$/.test(name)) {\n\t\treturn false; // require a name that is not just whitespace\n\t}\n\n\tinvalidFileChars.lastIndex = 0; // the holy grail of software development\n\tif (invalidFileChars.test(name)) {\n\t\treturn false; // check for certain invalid file characters\n\t}\n\n\tif (isWindowsOS && WINDOWS_FORBIDDEN_NAMES.test(name)) {\n\t\treturn false; // check for certain invalid file names\n\t}\n\n\tif (name === '.' || name === '..') {\n\t\treturn false; // check for reserved values\n\t}\n\n\tif (isWindowsOS && name[name.length - 1] === '.') {\n\t\treturn false; // Windows: file cannot end with a \".\"\n\t}\n\n\tif (isWindowsOS && name.length !== name.trim().length) {\n\t\treturn false; // Windows: file cannot end with a whitespace\n\t}\n\n\tif (name.length > 255) {\n\t\treturn false; // most file systems do not allow files > 255 length\n\t}\n\n\treturn true;\n}\n\nexport function isEqual(pathA: string, pathB: string, ignoreCase?: boolean): boolean {\n\tconst identityEquals = (pathA === pathB);\n\tif (!ignoreCase || identityEquals) {\n\t\treturn identityEquals;\n\t}\n\n\tif (!pathA || !pathB) {\n\t\treturn false;\n\t}\n\n\treturn equalsIgnoreCase(pathA, pathB);\n}\n\nexport function isEqualOrParent(path: string, candidate: string, ignoreCase?: boolean, separator = sep): boolean {\n\tif (path === candidate) {\n\t\treturn true;\n\t}\n\n\tif (!path || !candidate) {\n\t\treturn false;\n\t}\n\n\tif (candidate.length > path.length) {\n\t\treturn false;\n\t}\n\n\tif (ignoreCase) {\n\t\tconst beginsWith = startsWithIgnoreCase(path, candidate);\n\t\tif (!beginsWith) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (candidate.length === path.length) {\n\t\t\treturn true; // same path, different casing\n\t\t}\n\n\t\tlet sepOffset = candidate.length;\n\t\tif (candidate.charAt(candidate.length - 1) === separator) {\n\t\t\tsepOffset--; // adjust the expected sep offset in case our candidate already ends in separator character\n\t\t}\n\n\t\treturn path.charAt(sepOffset) === separator;\n\t}\n\n\tif (candidate.charAt(candidate.length - 1) !== separator) {\n\t\tcandidate += separator;\n\t}\n\n\treturn path.indexOf(candidate) === 0;\n}\n\nexport function isWindowsDriveLetter(char0: number): boolean {\n\treturn char0 >= CharCode.A && char0 <= CharCode.Z || char0 >= CharCode.a && char0 <= CharCode.z;\n}\n\nexport function sanitizeFilePath(candidate: string, cwd: string): string {\n\n\t// Special case: allow to open a drive letter without trailing backslash\n\tif (isWindows && endsWith(candidate, ':')) {\n\t\tcandidate += sep;\n\t}\n\n\t// Ensure absolute\n\tif (!isAbsolute(candidate)) {\n\t\tcandidate = join(cwd, candidate);\n\t}\n\n\t// Ensure normalized\n\tcandidate = normalize(candidate);\n\n\t// Ensure no trailing slash/backslash\n\tif (isWindows) {\n\t\tcandidate = rtrim(candidate, sep);\n\n\t\t// Special case: allow to open drive root ('C:\\')\n\t\tif (endsWith(candidate, ':')) {\n\t\t\tcandidate += sep;\n\t\t}\n\n\t} else {\n\t\tcandidate = rtrim(candidate, sep);\n\n\t\t// Special case: allow to open root ('/')\n\t\tif (!candidate) {\n\t\t\tcandidate = sep;\n\t\t}\n\t}\n\n\treturn candidate;\n}\n\nexport function isRootOrDriveLetter(path: string): boolean {\n\tconst pathNormalized = normalize(path);\n\n\tif (isWindows) {\n\t\tif (path.length > 3) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn isWindowsDriveLetter(pathNormalized.charCodeAt(0))\n\t\t\t&& pathNormalized.charCodeAt(1) === CharCode.Colon\n\t\t\t&& (path.length === 2 || pathNormalized.charCodeAt(2) === CharCode.Backslash);\n\t}\n\n\treturn pathNormalized === posix.sep;\n}\n\nexport function indexOfPath(path: string, candidate: string, ignoreCase: boolean): number {\n\tif (candidate.length > path.length) {\n\t\treturn -1;\n\t}\n\n\tif (path === candidate) {\n\t\treturn 0;\n\t}\n\n\tif (ignoreCase) {\n\t\tpath = path.toLowerCase();\n\t\tcandidate = candidate.toLowerCase();\n\t}\n\n\treturn path.indexOf(candidate);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { URI } from 'vs/base/common/uri';\nimport { CharCode } from 'vs/base/common/charCode';\nimport { Iterator, IteratorResult, FIN } from './iterator';\n\n\nexport function values<V = any>(set: Set<V>): V[];\nexport function values<K = any, V = any>(map: Map<K, V>): V[];\nexport function values<V>(forEachable: { forEach(callback: (value: V, ...more: any[]) => any): void }): V[] {\n\tconst result: V[] = [];\n\tforEachable.forEach(value => result.push(value));\n\treturn result;\n}\n\nexport function keys<K, V>(map: Map<K, V>): K[] {\n\tconst result: K[] = [];\n\tmap.forEach((_value, key) => result.push(key));\n\n\treturn result;\n}\n\nexport function getOrSet<K, V>(map: Map<K, V>, key: K, value: V): V {\n\tlet result = map.get(key);\n\tif (result === undefined) {\n\t\tresult = value;\n\t\tmap.set(key, result);\n\t}\n\n\treturn result;\n}\n\nexport function mapToString<K, V>(map: Map<K, V>): string {\n\tconst entries: string[] = [];\n\tmap.forEach((value, key) => {\n\t\tentries.push(`${key} => ${value}`);\n\t});\n\n\treturn `Map(${map.size}) {${entries.join(', ')}}`;\n}\n\nexport function setToString<K>(set: Set<K>): string {\n\tconst entries: K[] = [];\n\tset.forEach(value => {\n\t\tentries.push(value);\n\t});\n\n\treturn `Set(${set.size}) {${entries.join(', ')}}`;\n}\n\nexport function mapToSerializable(map: Map<string, string>): [string, string][] {\n\tconst serializable: [string, string][] = [];\n\n\tmap.forEach((value, key) => {\n\t\tserializable.push([key, value]);\n\t});\n\n\treturn serializable;\n}\n\nexport function serializableToMap(serializable: [string, string][]): Map<string, string> {\n\tconst items = new Map<string, string>();\n\n\tfor (const [key, value] of serializable) {\n\t\titems.set(key, value);\n\t}\n\n\treturn items;\n}\n\nexport interface IKeyIterator {\n\treset(key: string): this;\n\tnext(): this;\n\n\thasNext(): boolean;\n\tcmp(a: string): number;\n\tvalue(): string;\n}\n\nexport class StringIterator implements IKeyIterator {\n\n\tprivate _value: string = '';\n\tprivate _pos: number = 0;\n\n\treset(key: string): this {\n\t\tthis._value = key;\n\t\tthis._pos = 0;\n\t\treturn this;\n\t}\n\n\tnext(): this {\n\t\tthis._pos += 1;\n\t\treturn this;\n\t}\n\n\thasNext(): boolean {\n\t\treturn this._pos < this._value.length - 1;\n\t}\n\n\tcmp(a: string): number {\n\t\tconst aCode = a.charCodeAt(0);\n\t\tconst thisCode = this._value.charCodeAt(this._pos);\n\t\treturn aCode - thisCode;\n\t}\n\n\tvalue(): string {\n\t\treturn this._value[this._pos];\n\t}\n}\n\nexport class PathIterator implements IKeyIterator {\n\n\tprivate _value!: string;\n\tprivate _from!: number;\n\tprivate _to!: number;\n\n\tconstructor(private _splitOnBackslash: boolean = true) { }\n\n\treset(key: string): this {\n\t\tthis._value = key.replace(/\\\\$|\\/$/, '');\n\t\tthis._from = 0;\n\t\tthis._to = 0;\n\t\treturn this.next();\n\t}\n\n\thasNext(): boolean {\n\t\treturn this._to < this._value.length;\n\t}\n\n\tnext(): this {\n\t\t// this._data = key.split(/[\\\\/]/).filter(s => !!s);\n\t\tthis._from = this._to;\n\t\tlet justSeps = true;\n\t\tfor (; this._to < this._value.length; this._to++) {\n\t\t\tconst ch = this._value.charCodeAt(this._to);\n\t\t\tif (ch === CharCode.Slash || this._splitOnBackslash && ch === CharCode.Backslash) {\n\t\t\t\tif (justSeps) {\n\t\t\t\t\tthis._from++;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tjustSeps = false;\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\tcmp(a: string): number {\n\n\t\tlet aPos = 0;\n\t\tconst aLen = a.length;\n\t\tlet thisPos = this._from;\n\n\t\twhile (aPos < aLen && thisPos < this._to) {\n\t\t\tconst cmp = a.charCodeAt(aPos) - this._value.charCodeAt(thisPos);\n\t\t\tif (cmp !== 0) {\n\t\t\t\treturn cmp;\n\t\t\t}\n\t\t\taPos += 1;\n\t\t\tthisPos += 1;\n\t\t}\n\n\t\tif (aLen === this._to - this._from) {\n\t\t\treturn 0;\n\t\t} else if (aPos < aLen) {\n\t\t\treturn -1;\n\t\t} else {\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tvalue(): string {\n\t\treturn this._value.substring(this._from, this._to);\n\t}\n}\n\nclass TernarySearchTreeNode<E> {\n\tsegment!: string;\n\tvalue: E | undefined;\n\tkey!: string;\n\tleft: TernarySearchTreeNode<E> | undefined;\n\tmid: TernarySearchTreeNode<E> | undefined;\n\tright: TernarySearchTreeNode<E> | undefined;\n\n\tisEmpty(): boolean {\n\t\treturn !this.left && !this.mid && !this.right && !this.value;\n\t}\n}\n\nexport class TernarySearchTree<E> {\n\n\tstatic forPaths<E>(): TernarySearchTree<E> {\n\t\treturn new TernarySearchTree<E>(new PathIterator());\n\t}\n\n\tstatic forStrings<E>(): TernarySearchTree<E> {\n\t\treturn new TernarySearchTree<E>(new StringIterator());\n\t}\n\n\tprivate _iter: IKeyIterator;\n\tprivate _root: TernarySearchTreeNode<E> | undefined;\n\n\tconstructor(segments: IKeyIterator) {\n\t\tthis._iter = segments;\n\t}\n\n\tclear(): void {\n\t\tthis._root = undefined;\n\t}\n\n\tset(key: string, element: E): E | undefined {\n\t\tconst iter = this._iter.reset(key);\n\t\tlet node: TernarySearchTreeNode<E>;\n\n\t\tif (!this._root) {\n\t\t\tthis._root = new TernarySearchTreeNode<E>();\n\t\t\tthis._root.segment = iter.value();\n\t\t}\n\n\t\tnode = this._root;\n\t\twhile (true) {\n\t\t\tconst val = iter.cmp(node.segment);\n\t\t\tif (val > 0) {\n\t\t\t\t// left\n\t\t\t\tif (!node.left) {\n\t\t\t\t\tnode.left = new TernarySearchTreeNode<E>();\n\t\t\t\t\tnode.left.segment = iter.value();\n\t\t\t\t}\n\t\t\t\tnode = node.left;\n\n\t\t\t} else if (val < 0) {\n\t\t\t\t// right\n\t\t\t\tif (!node.right) {\n\t\t\t\t\tnode.right = new TernarySearchTreeNode<E>();\n\t\t\t\t\tnode.right.segment = iter.value();\n\t\t\t\t}\n\t\t\t\tnode = node.right;\n\n\t\t\t} else if (iter.hasNext()) {\n\t\t\t\t// mid\n\t\t\t\titer.next();\n\t\t\t\tif (!node.mid) {\n\t\t\t\t\tnode.mid = new TernarySearchTreeNode<E>();\n\t\t\t\t\tnode.mid.segment = iter.value();\n\t\t\t\t}\n\t\t\t\tnode = node.mid;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tconst oldElement = node.value;\n\t\tnode.value = element;\n\t\tnode.key = key;\n\t\treturn oldElement;\n\t}\n\n\tget(key: string): E | undefined {\n\t\tconst iter = this._iter.reset(key);\n\t\tlet node = this._root;\n\t\twhile (node) {\n\t\t\tconst val = iter.cmp(node.segment);\n\t\t\tif (val > 0) {\n\t\t\t\t// left\n\t\t\t\tnode = node.left;\n\t\t\t} else if (val < 0) {\n\t\t\t\t// right\n\t\t\t\tnode = node.right;\n\t\t\t} else if (iter.hasNext()) {\n\t\t\t\t// mid\n\t\t\t\titer.next();\n\t\t\t\tnode = node.mid;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn node ? node.value : undefined;\n\t}\n\n\tdelete(key: string): void {\n\n\t\tconst iter = this._iter.reset(key);\n\t\tconst stack: [-1 | 0 | 1, TernarySearchTreeNode<E>][] = [];\n\t\tlet node = this._root;\n\n\t\t// find and unset node\n\t\twhile (node) {\n\t\t\tconst val = iter.cmp(node.segment);\n\t\t\tif (val > 0) {\n\t\t\t\t// left\n\t\t\t\tstack.push([1, node]);\n\t\t\t\tnode = node.left;\n\t\t\t} else if (val < 0) {\n\t\t\t\t// right\n\t\t\t\tstack.push([-1, node]);\n\t\t\t\tnode = node.right;\n\t\t\t} else if (iter.hasNext()) {\n\t\t\t\t// mid\n\t\t\t\titer.next();\n\t\t\t\tstack.push([0, node]);\n\t\t\t\tnode = node.mid;\n\t\t\t} else {\n\t\t\t\t// remove element\n\t\t\t\tnode.value = undefined;\n\n\t\t\t\t// clean up empty nodes\n\t\t\t\twhile (stack.length > 0 && node.isEmpty()) {\n\t\t\t\t\tlet [dir, parent] = stack.pop()!;\n\t\t\t\t\tswitch (dir) {\n\t\t\t\t\t\tcase 1: parent.left = undefined; break;\n\t\t\t\t\t\tcase 0: parent.mid = undefined; break;\n\t\t\t\t\t\tcase -1: parent.right = undefined; break;\n\t\t\t\t\t}\n\t\t\t\t\tnode = parent;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tfindSubstr(key: string): E | undefined {\n\t\tconst iter = this._iter.reset(key);\n\t\tlet node = this._root;\n\t\tlet candidate: E | undefined = undefined;\n\t\twhile (node) {\n\t\t\tconst val = iter.cmp(node.segment);\n\t\t\tif (val > 0) {\n\t\t\t\t// left\n\t\t\t\tnode = node.left;\n\t\t\t} else if (val < 0) {\n\t\t\t\t// right\n\t\t\t\tnode = node.right;\n\t\t\t} else if (iter.hasNext()) {\n\t\t\t\t// mid\n\t\t\t\titer.next();\n\t\t\t\tcandidate = node.value || candidate;\n\t\t\t\tnode = node.mid;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn node && node.value || candidate;\n\t}\n\n\tfindSuperstr(key: string): Iterator<E> | undefined {\n\t\tconst iter = this._iter.reset(key);\n\t\tlet node = this._root;\n\t\twhile (node) {\n\t\t\tconst val = iter.cmp(node.segment);\n\t\t\tif (val > 0) {\n\t\t\t\t// left\n\t\t\t\tnode = node.left;\n\t\t\t} else if (val < 0) {\n\t\t\t\t// right\n\t\t\t\tnode = node.right;\n\t\t\t} else if (iter.hasNext()) {\n\t\t\t\t// mid\n\t\t\t\titer.next();\n\t\t\t\tnode = node.mid;\n\t\t\t} else {\n\t\t\t\t// collect\n\t\t\t\tif (!node.mid) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t} else {\n\t\t\t\t\treturn this._nodeIterator(node.mid);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tprivate _nodeIterator(node: TernarySearchTreeNode<E>): Iterator<E> {\n\t\tlet res: { done: false; value: E; };\n\t\tlet idx: number;\n\t\tlet data: E[];\n\t\tconst next = (): IteratorResult<E> => {\n\t\t\tif (!data) {\n\t\t\t\t// lazy till first invocation\n\t\t\t\tdata = [];\n\t\t\t\tidx = 0;\n\t\t\t\tthis._forEach(node, value => data.push(value));\n\t\t\t}\n\t\t\tif (idx >= data.length) {\n\t\t\t\treturn FIN;\n\t\t\t}\n\n\t\t\tif (!res) {\n\t\t\t\tres = { done: false, value: data[idx++] };\n\t\t\t} else {\n\t\t\t\tres.value = data[idx++];\n\t\t\t}\n\t\t\treturn res;\n\t\t};\n\t\treturn { next };\n\t}\n\n\tforEach(callback: (value: E, index: string) => any) {\n\t\tthis._forEach(this._root, callback);\n\t}\n\n\tprivate _forEach(node: TernarySearchTreeNode<E> | undefined, callback: (value: E, index: string) => any) {\n\t\tif (node) {\n\t\t\t// left\n\t\t\tthis._forEach(node.left, callback);\n\n\t\t\t// node\n\t\t\tif (node.value) {\n\t\t\t\t// callback(node.value, this._iter.join(parts));\n\t\t\t\tcallback(node.value, node.key);\n\t\t\t}\n\t\t\t// mid\n\t\t\tthis._forEach(node.mid, callback);\n\n\t\t\t// right\n\t\t\tthis._forEach(node.right, callback);\n\t\t}\n\t}\n}\n\nexport class ResourceMap<T> {\n\n\tprotected readonly map: Map<string, T>;\n\tprotected readonly ignoreCase?: boolean;\n\n\tconstructor() {\n\t\tthis.map = new Map<string, T>();\n\t\tthis.ignoreCase = false; // in the future this should be an uri-comparator\n\t}\n\n\tset(resource: URI, value: T): void {\n\t\tthis.map.set(this.toKey(resource), value);\n\t}\n\n\tget(resource: URI): T | undefined {\n\t\treturn this.map.get(this.toKey(resource));\n\t}\n\n\thas(resource: URI): boolean {\n\t\treturn this.map.has(this.toKey(resource));\n\t}\n\n\tget size(): number {\n\t\treturn this.map.size;\n\t}\n\n\tclear(): void {\n\t\tthis.map.clear();\n\t}\n\n\tdelete(resource: URI): boolean {\n\t\treturn this.map.delete(this.toKey(resource));\n\t}\n\n\tforEach(clb: (value: T, key: URI) => void): void {\n\t\tthis.map.forEach((value, index) => clb(value, URI.parse(index)));\n\t}\n\n\tvalues(): T[] {\n\t\treturn values(this.map);\n\t}\n\n\tprivate toKey(resource: URI): string {\n\t\tlet key = resource.toString();\n\t\tif (this.ignoreCase) {\n\t\t\tkey = key.toLowerCase();\n\t\t}\n\n\t\treturn key;\n\t}\n\n\tkeys(): URI[] {\n\t\treturn keys(this.map).map(k => URI.parse(k));\n\t}\n\n\tclone(): ResourceMap<T> {\n\t\tconst resourceMap = new ResourceMap<T>();\n\n\t\tthis.map.forEach((value, key) => resourceMap.map.set(key, value));\n\n\t\treturn resourceMap;\n\t}\n}\n\ninterface Item<K, V> {\n\tprevious: Item<K, V> | undefined;\n\tnext: Item<K, V> | undefined;\n\tkey: K;\n\tvalue: V;\n}\n\nexport const enum Touch {\n\tNone = 0,\n\tAsOld = 1,\n\tAsNew = 2\n}\n\nexport class LinkedMap<K, V> {\n\n\tprivate _map: Map<K, Item<K, V>>;\n\tprivate _head: Item<K, V> | undefined;\n\tprivate _tail: Item<K, V> | undefined;\n\tprivate _size: number;\n\n\tconstructor() {\n\t\tthis._map = new Map<K, Item<K, V>>();\n\t\tthis._head = undefined;\n\t\tthis._tail = undefined;\n\t\tthis._size = 0;\n\t}\n\n\tclear(): void {\n\t\tthis._map.clear();\n\t\tthis._head = undefined;\n\t\tthis._tail = undefined;\n\t\tthis._size = 0;\n\t}\n\n\tisEmpty(): boolean {\n\t\treturn !this._head && !this._tail;\n\t}\n\n\tget size(): number {\n\t\treturn this._size;\n\t}\n\n\tget first(): V | undefined {\n\t\treturn this._head?.value;\n\t}\n\n\tget last(): V | undefined {\n\t\treturn this._tail?.value;\n\t}\n\n\thas(key: K): boolean {\n\t\treturn this._map.has(key);\n\t}\n\n\tget(key: K, touch: Touch = Touch.None): V | undefined {\n\t\tconst item = this._map.get(key);\n\t\tif (!item) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (touch !== Touch.None) {\n\t\t\tthis.touch(item, touch);\n\t\t}\n\t\treturn item.value;\n\t}\n\n\tset(key: K, value: V, touch: Touch = Touch.None): void {\n\t\tlet item = this._map.get(key);\n\t\tif (item) {\n\t\t\titem.value = value;\n\t\t\tif (touch !== Touch.None) {\n\t\t\t\tthis.touch(item, touch);\n\t\t\t}\n\t\t} else {\n\t\t\titem = { key, value, next: undefined, previous: undefined };\n\t\t\tswitch (touch) {\n\t\t\t\tcase Touch.None:\n\t\t\t\t\tthis.addItemLast(item);\n\t\t\t\t\tbreak;\n\t\t\t\tcase Touch.AsOld:\n\t\t\t\t\tthis.addItemFirst(item);\n\t\t\t\t\tbreak;\n\t\t\t\tcase Touch.AsNew:\n\t\t\t\t\tthis.addItemLast(item);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthis.addItemLast(item);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tthis._map.set(key, item);\n\t\t\tthis._size++;\n\t\t}\n\t}\n\n\tdelete(key: K): boolean {\n\t\treturn !!this.remove(key);\n\t}\n\n\tremove(key: K): V | undefined {\n\t\tconst item = this._map.get(key);\n\t\tif (!item) {\n\t\t\treturn undefined;\n\t\t}\n\t\tthis._map.delete(key);\n\t\tthis.removeItem(item);\n\t\tthis._size--;\n\t\treturn item.value;\n\t}\n\n\tshift(): V | undefined {\n\t\tif (!this._head && !this._tail) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (!this._head || !this._tail) {\n\t\t\tthrow new Error('Invalid list');\n\t\t}\n\t\tconst item = this._head;\n\t\tthis._map.delete(item.key);\n\t\tthis.removeItem(item);\n\t\tthis._size--;\n\t\treturn item.value;\n\t}\n\n\tforEach(callbackfn: (value: V, key: K, map: LinkedMap<K, V>) => void, thisArg?: any): void {\n\t\tlet current = this._head;\n\t\twhile (current) {\n\t\t\tif (thisArg) {\n\t\t\t\tcallbackfn.bind(thisArg)(current.value, current.key, this);\n\t\t\t} else {\n\t\t\t\tcallbackfn(current.value, current.key, this);\n\t\t\t}\n\t\t\tcurrent = current.next;\n\t\t}\n\t}\n\n\tvalues(): V[] {\n\t\tconst result: V[] = [];\n\t\tlet current = this._head;\n\t\twhile (current) {\n\t\t\tresult.push(current.value);\n\t\t\tcurrent = current.next;\n\t\t}\n\t\treturn result;\n\t}\n\n\tkeys(): K[] {\n\t\tconst result: K[] = [];\n\t\tlet current = this._head;\n\t\twhile (current) {\n\t\t\tresult.push(current.key);\n\t\t\tcurrent = current.next;\n\t\t}\n\t\treturn result;\n\t}\n\n\t/* VS Code / Monaco editor runs on es5 which has no Symbol.iterator\n\tkeys(): IterableIterator<K> {\n\t\tconst current = this._head;\n\t\tconst iterator: IterableIterator<K> = {\n\t\t\t[Symbol.iterator]() {\n\t\t\t\treturn iterator;\n\t\t\t},\n\t\t\tnext():IteratorResult<K> {\n\t\t\t\tif (current) {\n\t\t\t\t\tconst result = { value: current.key, done: false };\n\t\t\t\t\tcurrent = current.next;\n\t\t\t\t\treturn result;\n\t\t\t\t} else {\n\t\t\t\t\treturn { value: undefined, done: true };\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\treturn iterator;\n\t}\n\n\tvalues(): IterableIterator<V> {\n\t\tconst current = this._head;\n\t\tconst iterator: IterableIterator<V> = {\n\t\t\t[Symbol.iterator]() {\n\t\t\t\treturn iterator;\n\t\t\t},\n\t\t\tnext():IteratorResult<V> {\n\t\t\t\tif (current) {\n\t\t\t\t\tconst result = { value: current.value, done: false };\n\t\t\t\t\tcurrent = current.next;\n\t\t\t\t\treturn result;\n\t\t\t\t} else {\n\t\t\t\t\treturn { value: undefined, done: true };\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\treturn iterator;\n\t}\n\t*/\n\n\tprotected trimOld(newSize: number) {\n\t\tif (newSize >= this.size) {\n\t\t\treturn;\n\t\t}\n\t\tif (newSize === 0) {\n\t\t\tthis.clear();\n\t\t\treturn;\n\t\t}\n\t\tlet current = this._head;\n\t\tlet currentSize = this.size;\n\t\twhile (current && currentSize > newSize) {\n\t\t\tthis._map.delete(current.key);\n\t\t\tcurrent = current.next;\n\t\t\tcurrentSize--;\n\t\t}\n\t\tthis._head = current;\n\t\tthis._size = currentSize;\n\t\tif (current) {\n\t\t\tcurrent.previous = undefined;\n\t\t}\n\t}\n\n\tprivate addItemFirst(item: Item<K, V>): void {\n\t\t// First time Insert\n\t\tif (!this._head && !this._tail) {\n\t\t\tthis._tail = item;\n\t\t} else if (!this._head) {\n\t\t\tthrow new Error('Invalid list');\n\t\t} else {\n\t\t\titem.next = this._head;\n\t\t\tthis._head.previous = item;\n\t\t}\n\t\tthis._head = item;\n\t}\n\n\tprivate addItemLast(item: Item<K, V>): void {\n\t\t// First time Insert\n\t\tif (!this._head && !this._tail) {\n\t\t\tthis._head = item;\n\t\t} else if (!this._tail) {\n\t\t\tthrow new Error('Invalid list');\n\t\t} else {\n\t\t\titem.previous = this._tail;\n\t\t\tthis._tail.next = item;\n\t\t}\n\t\tthis._tail = item;\n\t}\n\n\tprivate removeItem(item: Item<K, V>): void {\n\t\tif (item === this._head && item === this._tail) {\n\t\t\tthis._head = undefined;\n\t\t\tthis._tail = undefined;\n\t\t}\n\t\telse if (item === this._head) {\n\t\t\t// This can only happend if size === 1 which is handle\n\t\t\t// by the case above.\n\t\t\tif (!item.next) {\n\t\t\t\tthrow new Error('Invalid list');\n\t\t\t}\n\t\t\titem.next.previous = undefined;\n\t\t\tthis._head = item.next;\n\t\t}\n\t\telse if (item === this._tail) {\n\t\t\t// This can only happend if size === 1 which is handle\n\t\t\t// by the case above.\n\t\t\tif (!item.previous) {\n\t\t\t\tthrow new Error('Invalid list');\n\t\t\t}\n\t\t\titem.previous.next = undefined;\n\t\t\tthis._tail = item.previous;\n\t\t}\n\t\telse {\n\t\t\tconst next = item.next;\n\t\t\tconst previous = item.previous;\n\t\t\tif (!next || !previous) {\n\t\t\t\tthrow new Error('Invalid list');\n\t\t\t}\n\t\t\tnext.previous = previous;\n\t\t\tprevious.next = next;\n\t\t}\n\t\titem.next = undefined;\n\t\titem.previous = undefined;\n\t}\n\n\tprivate touch(item: Item<K, V>, touch: Touch): void {\n\t\tif (!this._head || !this._tail) {\n\t\t\tthrow new Error('Invalid list');\n\t\t}\n\t\tif ((touch !== Touch.AsOld && touch !== Touch.AsNew)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (touch === Touch.AsOld) {\n\t\t\tif (item === this._head) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst next = item.next;\n\t\t\tconst previous = item.previous;\n\n\t\t\t// Unlink the item\n\t\t\tif (item === this._tail) {\n\t\t\t\t// previous must be defined since item was not head but is tail\n\t\t\t\t// So there are more than on item in the map\n\t\t\t\tprevious!.next = undefined;\n\t\t\t\tthis._tail = previous;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Both next and previous are not undefined since item was neither head nor tail.\n\t\t\t\tnext!.previous = previous;\n\t\t\t\tprevious!.next = next;\n\t\t\t}\n\n\t\t\t// Insert the node at head\n\t\t\titem.previous = undefined;\n\t\t\titem.next = this._head;\n\t\t\tthis._head.previous = item;\n\t\t\tthis._head = item;\n\t\t} else if (touch === Touch.AsNew) {\n\t\t\tif (item === this._tail) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst next = item.next;\n\t\t\tconst previous = item.previous;\n\n\t\t\t// Unlink the item.\n\t\t\tif (item === this._head) {\n\t\t\t\t// next must be defined since item was not tail but is head\n\t\t\t\t// So there are more than on item in the map\n\t\t\t\tnext!.previous = undefined;\n\t\t\t\tthis._head = next;\n\t\t\t} else {\n\t\t\t\t// Both next and previous are not undefined since item was neither head nor tail.\n\t\t\t\tnext!.previous = previous;\n\t\t\t\tprevious!.next = next;\n\t\t\t}\n\t\t\titem.next = undefined;\n\t\t\titem.previous = this._tail;\n\t\t\tthis._tail.next = item;\n\t\t\tthis._tail = item;\n\t\t}\n\t}\n\n\ttoJSON(): [K, V][] {\n\t\tconst data: [K, V][] = [];\n\n\t\tthis.forEach((value, key) => {\n\t\t\tdata.push([key, value]);\n\t\t});\n\n\t\treturn data;\n\t}\n\n\tfromJSON(data: [K, V][]): void {\n\t\tthis.clear();\n\n\t\tfor (const [key, value] of data) {\n\t\t\tthis.set(key, value);\n\t\t}\n\t}\n}\n\nexport class LRUCache<K, V> extends LinkedMap<K, V> {\n\n\tprivate _limit: number;\n\tprivate _ratio: number;\n\n\tconstructor(limit: number, ratio: number = 1) {\n\t\tsuper();\n\t\tthis._limit = limit;\n\t\tthis._ratio = Math.min(Math.max(0, ratio), 1);\n\t}\n\n\tget limit(): number {\n\t\treturn this._limit;\n\t}\n\n\tset limit(limit: number) {\n\t\tthis._limit = limit;\n\t\tthis.checkTrim();\n\t}\n\n\tget ratio(): number {\n\t\treturn this._ratio;\n\t}\n\n\tset ratio(ratio: number) {\n\t\tthis._ratio = Math.min(Math.max(0, ratio), 1);\n\t\tthis.checkTrim();\n\t}\n\n\tget(key: K): V | undefined {\n\t\treturn super.get(key, Touch.AsNew);\n\t}\n\n\tpeek(key: K): V | undefined {\n\t\treturn super.get(key, Touch.None);\n\t}\n\n\tset(key: K, value: V): void {\n\t\tsuper.set(key, value, Touch.AsNew);\n\t\tthis.checkTrim();\n\t}\n\n\tprivate checkTrim() {\n\t\tif (this.size > this._limit) {\n\t\t\tthis.trimOld(Math.round(this._limit * this._ratio));\n\t\t}\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as arrays from 'vs/base/common/arrays';\nimport * as strings from 'vs/base/common/strings';\nimport * as extpath from 'vs/base/common/extpath';\nimport * as paths from 'vs/base/common/path';\nimport { LRUCache } from 'vs/base/common/map';\nimport { CharCode } from 'vs/base/common/charCode';\nimport { isThenable } from 'vs/base/common/async';\n\nexport interface IExpression {\n\t[pattern: string]: boolean | SiblingClause;\n}\n\nexport interface IRelativePattern {\n\tbase: string;\n\tpattern: string;\n}\n\nexport function getEmptyExpression(): IExpression {\n\treturn Object.create(null);\n}\n\nexport interface SiblingClause {\n\twhen: string;\n}\n\nconst GLOBSTAR = '**';\nconst GLOB_SPLIT = '/';\nconst PATH_REGEX = '[/\\\\\\\\]';\t\t// any slash or backslash\nconst NO_PATH_REGEX = '[^/\\\\\\\\]';\t// any non-slash and non-backslash\nconst ALL_FORWARD_SLASHES = /\\//g;\n\nfunction starsToRegExp(starCount: number): string {\n\tswitch (starCount) {\n\t\tcase 0:\n\t\t\treturn '';\n\t\tcase 1:\n\t\t\treturn `${NO_PATH_REGEX}*?`; // 1 star matches any number of characters except path separator (/ and \\) - non greedy (?)\n\t\tdefault:\n\t\t\t// Matches:  (Path Sep OR Path Val followed by Path Sep OR Path Sep followed by Path Val) 0-many times\n\t\t\t// Group is non capturing because we don't need to capture at all (?:...)\n\t\t\t// Overall we use non-greedy matching because it could be that we match too much\n\t\t\treturn `(?:${PATH_REGEX}|${NO_PATH_REGEX}+${PATH_REGEX}|${PATH_REGEX}${NO_PATH_REGEX}+)*?`;\n\t}\n}\n\nexport function splitGlobAware(pattern: string, splitChar: string): string[] {\n\tif (!pattern) {\n\t\treturn [];\n\t}\n\n\tconst segments: string[] = [];\n\n\tlet inBraces = false;\n\tlet inBrackets = false;\n\n\tlet curVal = '';\n\tfor (const char of pattern) {\n\t\tswitch (char) {\n\t\t\tcase splitChar:\n\t\t\t\tif (!inBraces && !inBrackets) {\n\t\t\t\t\tsegments.push(curVal);\n\t\t\t\t\tcurVal = '';\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '{':\n\t\t\t\tinBraces = true;\n\t\t\t\tbreak;\n\t\t\tcase '}':\n\t\t\t\tinBraces = false;\n\t\t\t\tbreak;\n\t\t\tcase '[':\n\t\t\t\tinBrackets = true;\n\t\t\t\tbreak;\n\t\t\tcase ']':\n\t\t\t\tinBrackets = false;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tcurVal += char;\n\t}\n\n\t// Tail\n\tif (curVal) {\n\t\tsegments.push(curVal);\n\t}\n\n\treturn segments;\n}\n\nfunction parseRegExp(pattern: string): string {\n\tif (!pattern) {\n\t\treturn '';\n\t}\n\n\tlet regEx = '';\n\n\t// Split up into segments for each slash found\n\tconst segments = splitGlobAware(pattern, GLOB_SPLIT);\n\n\t// Special case where we only have globstars\n\tif (segments.every(s => s === GLOBSTAR)) {\n\t\tregEx = '.*';\n\t}\n\n\t// Build regex over segments\n\telse {\n\t\tlet previousSegmentWasGlobStar = false;\n\t\tsegments.forEach((segment, index) => {\n\n\t\t\t// Globstar is special\n\t\t\tif (segment === GLOBSTAR) {\n\n\t\t\t\t// if we have more than one globstar after another, just ignore it\n\t\t\t\tif (!previousSegmentWasGlobStar) {\n\t\t\t\t\tregEx += starsToRegExp(2);\n\t\t\t\t\tpreviousSegmentWasGlobStar = true;\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// States\n\t\t\tlet inBraces = false;\n\t\t\tlet braceVal = '';\n\n\t\t\tlet inBrackets = false;\n\t\t\tlet bracketVal = '';\n\n\t\t\tfor (const char of segment) {\n\t\t\t\t// Support brace expansion\n\t\t\t\tif (char !== '}' && inBraces) {\n\t\t\t\t\tbraceVal += char;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Support brackets\n\t\t\t\tif (inBrackets && (char !== ']' || !bracketVal) /* ] is literally only allowed as first character in brackets to match it */) {\n\t\t\t\t\tlet res: string;\n\n\t\t\t\t\t// range operator\n\t\t\t\t\tif (char === '-') {\n\t\t\t\t\t\tres = char;\n\t\t\t\t\t}\n\n\t\t\t\t\t// negation operator (only valid on first index in bracket)\n\t\t\t\t\telse if ((char === '^' || char === '!') && !bracketVal) {\n\t\t\t\t\t\tres = '^';\n\t\t\t\t\t}\n\n\t\t\t\t\t// glob split matching is not allowed within character ranges\n\t\t\t\t\t// see http://man7.org/linux/man-pages/man7/glob.7.html\n\t\t\t\t\telse if (char === GLOB_SPLIT) {\n\t\t\t\t\t\tres = '';\n\t\t\t\t\t}\n\n\t\t\t\t\t// anything else gets escaped\n\t\t\t\t\telse {\n\t\t\t\t\t\tres = strings.escapeRegExpCharacters(char);\n\t\t\t\t\t}\n\n\t\t\t\t\tbracketVal += res;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tswitch (char) {\n\t\t\t\t\tcase '{':\n\t\t\t\t\t\tinBraces = true;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tcase '[':\n\t\t\t\t\t\tinBrackets = true;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tcase '}':\n\t\t\t\t\t\tconst choices = splitGlobAware(braceVal, ',');\n\n\t\t\t\t\t\t// Converts {foo,bar} => [foo|bar]\n\t\t\t\t\t\tconst braceRegExp = `(?:${choices.map(c => parseRegExp(c)).join('|')})`;\n\n\t\t\t\t\t\tregEx += braceRegExp;\n\n\t\t\t\t\t\tinBraces = false;\n\t\t\t\t\t\tbraceVal = '';\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ']':\n\t\t\t\t\t\tregEx += ('[' + bracketVal + ']');\n\n\t\t\t\t\t\tinBrackets = false;\n\t\t\t\t\t\tbracketVal = '';\n\n\t\t\t\t\t\tbreak;\n\n\n\t\t\t\t\tcase '?':\n\t\t\t\t\t\tregEx += NO_PATH_REGEX; // 1 ? matches any single character except path separator (/ and \\)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tcase '*':\n\t\t\t\t\t\tregEx += starsToRegExp(1);\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tregEx += strings.escapeRegExpCharacters(char);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Tail: Add the slash we had split on if there is more to come and the remaining pattern is not a globstar\n\t\t\t// For example if pattern: some/**/*.js we want the \"/\" after some to be included in the RegEx to prevent\n\t\t\t// a folder called \"something\" to match as well.\n\t\t\t// However, if pattern: some/**, we tolerate that we also match on \"something\" because our globstar behaviour\n\t\t\t// is to match 0-N segments.\n\t\t\tif (index < segments.length - 1 && (segments[index + 1] !== GLOBSTAR || index + 2 < segments.length)) {\n\t\t\t\tregEx += PATH_REGEX;\n\t\t\t}\n\n\t\t\t// reset state\n\t\t\tpreviousSegmentWasGlobStar = false;\n\t\t});\n\t}\n\n\treturn regEx;\n}\n\n// regexes to check for trival glob patterns that just check for String#endsWith\nconst T1 = /^\\*\\*\\/\\*\\.[\\w\\.-]+$/; \t\t\t\t\t\t   \t\t\t// **/*.something\nconst T2 = /^\\*\\*\\/([\\w\\.-]+)\\/?$/; \t\t\t\t\t\t\t   \t\t\t// **/something\nconst T3 = /^{\\*\\*\\/[\\*\\.]?[\\w\\.-]+\\/?(,\\*\\*\\/[\\*\\.]?[\\w\\.-]+\\/?)*}$/; \t// {**/*.something,**/*.else} or {**/package.json,**/project.json}\nconst T3_2 = /^{\\*\\*\\/[\\*\\.]?[\\w\\.-]+(\\/(\\*\\*)?)?(,\\*\\*\\/[\\*\\.]?[\\w\\.-]+(\\/(\\*\\*)?)?)*}$/; \t// Like T3, with optional trailing /**\nconst T4 = /^\\*\\*((\\/[\\w\\.-]+)+)\\/?$/; \t\t\t\t\t\t   \t\t\t// **/something/else\nconst T5 = /^([\\w\\.-]+(\\/[\\w\\.-]+)*)\\/?$/; \t\t\t\t\t\t   \t\t// something/else\n\nexport type ParsedPattern = (path: string, basename?: string) => boolean;\n\n// The ParsedExpression returns a Promise iff hasSibling returns a Promise.\nexport type ParsedExpression = (path: string, basename?: string, hasSibling?: (name: string) => boolean | Promise<boolean>) => string | null | Promise<string | null> /* the matching pattern */;\n\nexport interface IGlobOptions {\n\t/**\n\t * Simplify patterns for use as exclusion filters during tree traversal to skip entire subtrees. Cannot be used outside of a tree traversal.\n\t */\n\ttrimForExclusions?: boolean;\n}\n\ninterface ParsedStringPattern {\n\t(path: string, basename?: string): string | null | Promise<string | null> /* the matching pattern */;\n\tbasenames?: string[];\n\tpatterns?: string[];\n\tallBasenames?: string[];\n\tallPaths?: string[];\n}\ninterface ParsedExpressionPattern {\n\t(path: string, basename?: string, name?: string, hasSibling?: (name: string) => boolean | Promise<boolean>): string | null | Promise<string | null> /* the matching pattern */;\n\trequiresSiblings?: boolean;\n\tallBasenames?: string[];\n\tallPaths?: string[];\n}\n\nconst CACHE = new LRUCache<string, ParsedStringPattern>(10000); // bounded to 10000 elements\n\nconst FALSE = function () {\n\treturn false;\n};\n\nconst NULL = function (): string | null {\n\treturn null;\n};\n\nfunction parsePattern(arg1: string | IRelativePattern, options: IGlobOptions): ParsedStringPattern {\n\tif (!arg1) {\n\t\treturn NULL;\n\t}\n\n\t// Handle IRelativePattern\n\tlet pattern: string;\n\tif (typeof arg1 !== 'string') {\n\t\tpattern = arg1.pattern;\n\t} else {\n\t\tpattern = arg1;\n\t}\n\n\t// Whitespace trimming\n\tpattern = pattern.trim();\n\n\t// Check cache\n\tconst patternKey = `${pattern}_${!!options.trimForExclusions}`;\n\tlet parsedPattern = CACHE.get(patternKey);\n\tif (parsedPattern) {\n\t\treturn wrapRelativePattern(parsedPattern, arg1);\n\t}\n\n\t// Check for Trivias\n\tlet match: RegExpExecArray | null;\n\tif (T1.test(pattern)) { // common pattern: **/*.txt just need endsWith check\n\t\tconst base = pattern.substr(4); // '**/*'.length === 4\n\t\tparsedPattern = function (path, basename) {\n\t\t\treturn typeof path === 'string' && strings.endsWith(path, base) ? pattern : null;\n\t\t};\n\t} else if (match = T2.exec(trimForExclusions(pattern, options))) { // common pattern: **/some.txt just need basename check\n\t\tparsedPattern = trivia2(match[1], pattern);\n\t} else if ((options.trimForExclusions ? T3_2 : T3).test(pattern)) { // repetition of common patterns (see above) {**/*.txt,**/*.png}\n\t\tparsedPattern = trivia3(pattern, options);\n\t} else if (match = T4.exec(trimForExclusions(pattern, options))) { // common pattern: **/something/else just need endsWith check\n\t\tparsedPattern = trivia4and5(match[1].substr(1), pattern, true);\n\t} else if (match = T5.exec(trimForExclusions(pattern, options))) { // common pattern: something/else just need equals check\n\t\tparsedPattern = trivia4and5(match[1], pattern, false);\n\t}\n\n\t// Otherwise convert to pattern\n\telse {\n\t\tparsedPattern = toRegExp(pattern);\n\t}\n\n\t// Cache\n\tCACHE.set(patternKey, parsedPattern);\n\n\treturn wrapRelativePattern(parsedPattern, arg1);\n}\n\nfunction wrapRelativePattern(parsedPattern: ParsedStringPattern, arg2: string | IRelativePattern): ParsedStringPattern {\n\tif (typeof arg2 === 'string') {\n\t\treturn parsedPattern;\n\t}\n\n\treturn function (path, basename) {\n\t\tif (!extpath.isEqualOrParent(path, arg2.base)) {\n\t\t\treturn null;\n\t\t}\n\t\treturn parsedPattern(paths.relative(arg2.base, path), basename);\n\t};\n}\n\nfunction trimForExclusions(pattern: string, options: IGlobOptions): string {\n\treturn options.trimForExclusions && strings.endsWith(pattern, '/**') ? pattern.substr(0, pattern.length - 2) : pattern; // dropping **, tailing / is dropped later\n}\n\n// common pattern: **/some.txt just need basename check\nfunction trivia2(base: string, originalPattern: string): ParsedStringPattern {\n\tconst slashBase = `/${base}`;\n\tconst backslashBase = `\\\\${base}`;\n\tconst parsedPattern: ParsedStringPattern = function (path, basename) {\n\t\tif (typeof path !== 'string') {\n\t\t\treturn null;\n\t\t}\n\t\tif (basename) {\n\t\t\treturn basename === base ? originalPattern : null;\n\t\t}\n\t\treturn path === base || strings.endsWith(path, slashBase) || strings.endsWith(path, backslashBase) ? originalPattern : null;\n\t};\n\tconst basenames = [base];\n\tparsedPattern.basenames = basenames;\n\tparsedPattern.patterns = [originalPattern];\n\tparsedPattern.allBasenames = basenames;\n\treturn parsedPattern;\n}\n\n// repetition of common patterns (see above) {**/*.txt,**/*.png}\nfunction trivia3(pattern: string, options: IGlobOptions): ParsedStringPattern {\n\tconst parsedPatterns = aggregateBasenameMatches(pattern.slice(1, -1).split(',')\n\t\t.map(pattern => parsePattern(pattern, options))\n\t\t.filter(pattern => pattern !== NULL), pattern);\n\tconst n = parsedPatterns.length;\n\tif (!n) {\n\t\treturn NULL;\n\t}\n\tif (n === 1) {\n\t\treturn <ParsedStringPattern>parsedPatterns[0];\n\t}\n\tconst parsedPattern: ParsedStringPattern = function (path: string, basename?: string) {\n\t\tfor (let i = 0, n = parsedPatterns.length; i < n; i++) {\n\t\t\tif ((<ParsedStringPattern>parsedPatterns[i])(path, basename)) {\n\t\t\t\treturn pattern;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t};\n\tconst withBasenames = arrays.first(parsedPatterns, pattern => !!(<ParsedStringPattern>pattern).allBasenames);\n\tif (withBasenames) {\n\t\tparsedPattern.allBasenames = (<ParsedStringPattern>withBasenames).allBasenames;\n\t}\n\tconst allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, <string[]>[]);\n\tif (allPaths.length) {\n\t\tparsedPattern.allPaths = allPaths;\n\t}\n\treturn parsedPattern;\n}\n\n// common patterns: **/something/else just need endsWith check, something/else just needs and equals check\nfunction trivia4and5(path: string, pattern: string, matchPathEnds: boolean): ParsedStringPattern {\n\tconst nativePath = paths.sep !== paths.posix.sep ? path.replace(ALL_FORWARD_SLASHES, paths.sep) : path;\n\tconst nativePathEnd = paths.sep + nativePath;\n\tconst parsedPattern: ParsedStringPattern = matchPathEnds ? function (path, basename) {\n\t\treturn typeof path === 'string' && (path === nativePath || strings.endsWith(path, nativePathEnd)) ? pattern : null;\n\t} : function (path, basename) {\n\t\treturn typeof path === 'string' && path === nativePath ? pattern : null;\n\t};\n\tparsedPattern.allPaths = [(matchPathEnds ? '*/' : './') + path];\n\treturn parsedPattern;\n}\n\nfunction toRegExp(pattern: string): ParsedStringPattern {\n\ttry {\n\t\tconst regExp = new RegExp(`^${parseRegExp(pattern)}$`);\n\t\treturn function (path: string) {\n\t\t\tregExp.lastIndex = 0; // reset RegExp to its initial state to reuse it!\n\t\t\treturn typeof path === 'string' && regExp.test(path) ? pattern : null;\n\t\t};\n\t} catch (error) {\n\t\treturn NULL;\n\t}\n}\n\n/**\n * Simplified glob matching. Supports a subset of glob patterns:\n * - * matches anything inside a path segment\n * - ? matches 1 character inside a path segment\n * - ** matches anything including an empty path segment\n * - simple brace expansion ({js,ts} => js or ts)\n * - character ranges (using [...])\n */\nexport function match(pattern: string | IRelativePattern, path: string): boolean;\nexport function match(expression: IExpression, path: string, hasSibling?: (name: string) => boolean): string /* the matching pattern */;\nexport function match(arg1: string | IExpression | IRelativePattern, path: string, hasSibling?: (name: string) => boolean): boolean | string | null | Promise<string | null> {\n\tif (!arg1 || typeof path !== 'string') {\n\t\treturn false;\n\t}\n\n\treturn parse(<IExpression>arg1)(path, undefined, hasSibling);\n}\n\n/**\n * Simplified glob matching. Supports a subset of glob patterns:\n * - * matches anything inside a path segment\n * - ? matches 1 character inside a path segment\n * - ** matches anything including an empty path segment\n * - simple brace expansion ({js,ts} => js or ts)\n * - character ranges (using [...])\n */\nexport function parse(pattern: string | IRelativePattern, options?: IGlobOptions): ParsedPattern;\nexport function parse(expression: IExpression, options?: IGlobOptions): ParsedExpression;\nexport function parse(arg1: string | IExpression | IRelativePattern, options: IGlobOptions = {}): ParsedPattern | ParsedExpression {\n\tif (!arg1) {\n\t\treturn FALSE;\n\t}\n\n\t// Glob with String\n\tif (typeof arg1 === 'string' || isRelativePattern(arg1)) {\n\t\tconst parsedPattern = parsePattern(arg1, options);\n\t\tif (parsedPattern === NULL) {\n\t\t\treturn FALSE;\n\t\t}\n\t\tconst resultPattern: ParsedPattern & { allBasenames?: string[]; allPaths?: string[]; } = function (path: string, basename?: string) {\n\t\t\treturn !!parsedPattern(path, basename);\n\t\t};\n\t\tif (parsedPattern.allBasenames) {\n\t\t\tresultPattern.allBasenames = parsedPattern.allBasenames;\n\t\t}\n\t\tif (parsedPattern.allPaths) {\n\t\t\tresultPattern.allPaths = parsedPattern.allPaths;\n\t\t}\n\t\treturn resultPattern;\n\t}\n\n\t// Glob with Expression\n\treturn parsedExpression(<IExpression>arg1, options);\n}\n\nexport function hasSiblingPromiseFn(siblingsFn?: () => Promise<string[]>) {\n\tif (!siblingsFn) {\n\t\treturn undefined;\n\t}\n\n\tlet siblings: Promise<Record<string, true>>;\n\treturn (name: string) => {\n\t\tif (!siblings) {\n\t\t\tsiblings = (siblingsFn() || Promise.resolve([]))\n\t\t\t\t.then(list => list ? listToMap(list) : {});\n\t\t}\n\t\treturn siblings.then(map => !!map[name]);\n\t};\n}\n\nexport function hasSiblingFn(siblingsFn?: () => string[]) {\n\tif (!siblingsFn) {\n\t\treturn undefined;\n\t}\n\n\tlet siblings: Record<string, true>;\n\treturn (name: string) => {\n\t\tif (!siblings) {\n\t\t\tconst list = siblingsFn();\n\t\t\tsiblings = list ? listToMap(list) : {};\n\t\t}\n\t\treturn !!siblings[name];\n\t};\n}\n\nfunction listToMap(list: string[]) {\n\tconst map: Record<string, true> = {};\n\tfor (const key of list) {\n\t\tmap[key] = true;\n\t}\n\treturn map;\n}\n\nexport function isRelativePattern(obj: unknown): obj is IRelativePattern {\n\tconst rp = obj as IRelativePattern;\n\n\treturn rp && typeof rp.base === 'string' && typeof rp.pattern === 'string';\n}\n\nexport function getBasenameTerms(patternOrExpression: ParsedPattern | ParsedExpression): string[] {\n\treturn (<ParsedStringPattern>patternOrExpression).allBasenames || [];\n}\n\nexport function getPathTerms(patternOrExpression: ParsedPattern | ParsedExpression): string[] {\n\treturn (<ParsedStringPattern>patternOrExpression).allPaths || [];\n}\n\nfunction parsedExpression(expression: IExpression, options: IGlobOptions): ParsedExpression {\n\tconst parsedPatterns = aggregateBasenameMatches(Object.getOwnPropertyNames(expression)\n\t\t.map(pattern => parseExpressionPattern(pattern, expression[pattern], options))\n\t\t.filter(pattern => pattern !== NULL));\n\n\tconst n = parsedPatterns.length;\n\tif (!n) {\n\t\treturn NULL;\n\t}\n\n\tif (!parsedPatterns.some(parsedPattern => !!(<ParsedExpressionPattern>parsedPattern).requiresSiblings)) {\n\t\tif (n === 1) {\n\t\t\treturn <ParsedStringPattern>parsedPatterns[0];\n\t\t}\n\n\t\tconst resultExpression: ParsedStringPattern = function (path: string, basename?: string) {\n\t\t\tfor (let i = 0, n = parsedPatterns.length; i < n; i++) {\n\t\t\t\t// Pattern matches path\n\t\t\t\tconst result = (<ParsedStringPattern>parsedPatterns[i])(path, basename);\n\t\t\t\tif (result) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn null;\n\t\t};\n\n\t\tconst withBasenames = arrays.first(parsedPatterns, pattern => !!(<ParsedStringPattern>pattern).allBasenames);\n\t\tif (withBasenames) {\n\t\t\tresultExpression.allBasenames = (<ParsedStringPattern>withBasenames).allBasenames;\n\t\t}\n\n\t\tconst allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, <string[]>[]);\n\t\tif (allPaths.length) {\n\t\t\tresultExpression.allPaths = allPaths;\n\t\t}\n\n\t\treturn resultExpression;\n\t}\n\n\tconst resultExpression: ParsedStringPattern = function (path: string, basename?: string, hasSibling?: (name: string) => boolean | Promise<boolean>) {\n\t\tlet name: string | undefined = undefined;\n\n\t\tfor (let i = 0, n = parsedPatterns.length; i < n; i++) {\n\t\t\t// Pattern matches path\n\t\t\tconst parsedPattern = (<ParsedExpressionPattern>parsedPatterns[i]);\n\t\t\tif (parsedPattern.requiresSiblings && hasSibling) {\n\t\t\t\tif (!basename) {\n\t\t\t\t\tbasename = paths.basename(path);\n\t\t\t\t}\n\t\t\t\tif (!name) {\n\t\t\t\t\tname = basename.substr(0, basename.length - paths.extname(path).length);\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst result = parsedPattern(path, basename, name, hasSibling);\n\t\t\tif (result) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t};\n\n\tconst withBasenames = arrays.first(parsedPatterns, pattern => !!(<ParsedStringPattern>pattern).allBasenames);\n\tif (withBasenames) {\n\t\tresultExpression.allBasenames = (<ParsedStringPattern>withBasenames).allBasenames;\n\t}\n\n\tconst allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, <string[]>[]);\n\tif (allPaths.length) {\n\t\tresultExpression.allPaths = allPaths;\n\t}\n\n\treturn resultExpression;\n}\n\nfunction parseExpressionPattern(pattern: string, value: boolean | SiblingClause, options: IGlobOptions): (ParsedStringPattern | ParsedExpressionPattern) {\n\tif (value === false) {\n\t\treturn NULL; // pattern is disabled\n\t}\n\n\tconst parsedPattern = parsePattern(pattern, options);\n\tif (parsedPattern === NULL) {\n\t\treturn NULL;\n\t}\n\n\t// Expression Pattern is <boolean>\n\tif (typeof value === 'boolean') {\n\t\treturn parsedPattern;\n\t}\n\n\t// Expression Pattern is <SiblingClause>\n\tif (value) {\n\t\tconst when = (<SiblingClause>value).when;\n\t\tif (typeof when === 'string') {\n\t\t\tconst result: ParsedExpressionPattern = (path: string, basename?: string, name?: string, hasSibling?: (name: string) => boolean | Promise<boolean>) => {\n\t\t\t\tif (!hasSibling || !parsedPattern(path, basename)) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tconst clausePattern = when.replace('$(basename)', name!);\n\t\t\t\tconst matched = hasSibling(clausePattern);\n\t\t\t\treturn isThenable(matched) ?\n\t\t\t\t\tmatched.then(m => m ? pattern : null) :\n\t\t\t\t\tmatched ? pattern : null;\n\t\t\t};\n\t\t\tresult.requiresSiblings = true;\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t// Expression is Anything\n\treturn parsedPattern;\n}\n\nfunction aggregateBasenameMatches(parsedPatterns: Array<ParsedStringPattern | ParsedExpressionPattern>, result?: string): Array<ParsedStringPattern | ParsedExpressionPattern> {\n\tconst basenamePatterns = parsedPatterns.filter(parsedPattern => !!(<ParsedStringPattern>parsedPattern).basenames);\n\tif (basenamePatterns.length < 2) {\n\t\treturn parsedPatterns;\n\t}\n\n\tconst basenames = basenamePatterns.reduce<string[]>((all, current) => {\n\t\tconst basenames = (<ParsedStringPattern>current).basenames;\n\t\treturn basenames ? all.concat(basenames) : all;\n\t}, <string[]>[]);\n\tlet patterns: string[];\n\tif (result) {\n\t\tpatterns = [];\n\t\tfor (let i = 0, n = basenames.length; i < n; i++) {\n\t\t\tpatterns.push(result);\n\t\t}\n\t} else {\n\t\tpatterns = basenamePatterns.reduce((all, current) => {\n\t\t\tconst patterns = (<ParsedStringPattern>current).patterns;\n\t\t\treturn patterns ? all.concat(patterns) : all;\n\t\t}, <string[]>[]);\n\t}\n\tconst aggregate: ParsedStringPattern = function (path, basename) {\n\t\tif (typeof path !== 'string') {\n\t\t\treturn null;\n\t\t}\n\t\tif (!basename) {\n\t\t\tlet i: number;\n\t\t\tfor (i = path.length; i > 0; i--) {\n\t\t\t\tconst ch = path.charCodeAt(i - 1);\n\t\t\t\tif (ch === CharCode.Slash || ch === CharCode.Backslash) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbasename = path.substr(i);\n\t\t}\n\t\tconst index = basenames.indexOf(basename);\n\t\treturn index !== -1 ? patterns[index] : null;\n\t};\n\taggregate.basenames = basenames;\n\taggregate.patterns = patterns;\n\taggregate.allBasenames = basenames;\n\n\tconst aggregatedPatterns = parsedPatterns.filter(parsedPattern => !(<ParsedStringPattern>parsedPattern).basenames);\n\taggregatedPatterns.push(aggregate);\n\treturn aggregatedPatterns;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { URI } from 'vs/base/common/uri';\nimport * as platform from 'vs/base/common/platform';\n\nexport namespace Schemas {\n\n\t/**\n\t * A schema that is used for models that exist in memory\n\t * only and that have no correspondence on a server or such.\n\t */\n\texport const inMemory = 'inmemory';\n\n\t/**\n\t * A schema that is used for setting files\n\t */\n\texport const vscode = 'vscode';\n\n\t/**\n\t * A schema that is used for internal private files\n\t */\n\texport const internal = 'private';\n\n\t/**\n\t * A walk-through document.\n\t */\n\texport const walkThrough = 'walkThrough';\n\n\t/**\n\t * An embedded code snippet.\n\t */\n\texport const walkThroughSnippet = 'walkThroughSnippet';\n\n\texport const http = 'http';\n\n\texport const https = 'https';\n\n\texport const file = 'file';\n\n\texport const mailto = 'mailto';\n\n\texport const untitled = 'untitled';\n\n\texport const data = 'data';\n\n\texport const command = 'command';\n\n\texport const vscodeRemote = 'vscode-remote';\n\n\texport const vscodeRemoteResource = 'vscode-remote-resource';\n\n\texport const userData = 'vscode-userdata';\n}\n\nclass RemoteAuthoritiesImpl {\n\tprivate readonly _hosts: { [authority: string]: string | undefined; } = Object.create(null);\n\tprivate readonly _ports: { [authority: string]: number | undefined; } = Object.create(null);\n\tprivate readonly _connectionTokens: { [authority: string]: string | undefined; } = Object.create(null);\n\tprivate _preferredWebSchema: 'http' | 'https' = 'http';\n\tprivate _delegate: ((uri: URI) => URI) | null = null;\n\n\tsetPreferredWebSchema(schema: 'http' | 'https') {\n\t\tthis._preferredWebSchema = schema;\n\t}\n\n\tsetDelegate(delegate: (uri: URI) => URI): void {\n\t\tthis._delegate = delegate;\n\t}\n\n\tset(authority: string, host: string, port: number): void {\n\t\tthis._hosts[authority] = host;\n\t\tthis._ports[authority] = port;\n\t}\n\n\tsetConnectionToken(authority: string, connectionToken: string): void {\n\t\tthis._connectionTokens[authority] = connectionToken;\n\t}\n\n\trewrite(uri: URI): URI {\n\t\tif (this._delegate) {\n\t\t\treturn this._delegate(uri);\n\t\t}\n\t\tconst authority = uri.authority;\n\t\tlet host = this._hosts[authority];\n\t\tif (host && host.indexOf(':') !== -1) {\n\t\t\thost = `[${host}]`;\n\t\t}\n\t\t// const port = this._ports[authority];\n\t\tconst connectionToken = this._connectionTokens[authority];\n\t\tlet query = `path=${encodeURIComponent(uri.path)}`;\n\t\tif (typeof connectionToken === 'string') {\n\t\t\tquery += `&tkn=${encodeURIComponent(connectionToken)}`;\n\t\t}\n\t\t// NOTE@coder: Changed this to work against the current path.\n\t\treturn URI.from({\n\t\t\tscheme: platform.isWeb ? this._preferredWebSchema : Schemas.vscodeRemoteResource,\n\t\t\tauthority: window.location.host,\n\t\t\tpath: `${window.location.pathname.replace(/\\/+$/, '')}/vscode-remote-resource`,\n\t\t\tquery\n\t\t});\n\t}\n}\n\nexport const RemoteAuthorities = new RemoteAuthoritiesImpl();\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as extpath from 'vs/base/common/extpath';\nimport * as paths from 'vs/base/common/path';\nimport { URI } from 'vs/base/common/uri';\nimport { equalsIgnoreCase } from 'vs/base/common/strings';\nimport { Schemas } from 'vs/base/common/network';\nimport { isLinux, isWindows } from 'vs/base/common/platform';\nimport { CharCode } from 'vs/base/common/charCode';\nimport { ParsedExpression, IExpression, parse } from 'vs/base/common/glob';\nimport { TernarySearchTree } from 'vs/base/common/map';\n\nexport function getComparisonKey(resource: URI): string {\n\treturn hasToIgnoreCase(resource) ? resource.toString().toLowerCase() : resource.toString();\n}\n\nexport function hasToIgnoreCase(resource: URI | undefined): boolean {\n\t// A file scheme resource is in the same platform as code, so ignore case for non linux platforms\n\t// Resource can be from another platform. Lowering the case as an hack. Should come from File system provider\n\treturn resource && resource.scheme === Schemas.file ? !isLinux : true;\n}\n\nexport function basenameOrAuthority(resource: URI): string {\n\treturn basename(resource) || resource.authority;\n}\n\n/**\n * Tests whether a `candidate` URI is a parent or equal of a given `base` URI.\n * @param base A uri which is \"longer\"\n * @param parentCandidate A uri which is \"shorter\" then `base`\n */\nexport function isEqualOrParent(base: URI, parentCandidate: URI, ignoreCase = hasToIgnoreCase(base)): boolean {\n\tif (base.scheme === parentCandidate.scheme) {\n\t\tif (base.scheme === Schemas.file) {\n\t\t\treturn extpath.isEqualOrParent(originalFSPath(base), originalFSPath(parentCandidate), ignoreCase);\n\t\t}\n\t\tif (isEqualAuthority(base.authority, parentCandidate.authority)) {\n\t\t\treturn extpath.isEqualOrParent(base.path, parentCandidate.path, ignoreCase, '/');\n\t\t}\n\t}\n\treturn false;\n}\n\n/**\n * Tests wheter the two authorities are the same\n */\nexport function isEqualAuthority(a1: string, a2: string) {\n\treturn a1 === a2 || equalsIgnoreCase(a1, a2);\n}\n\nexport function isEqual(first: URI | undefined, second: URI | undefined, ignoreCase = hasToIgnoreCase(first)): boolean {\n\tif (first === second) {\n\t\treturn true;\n\t}\n\n\tif (!first || !second) {\n\t\treturn false;\n\t}\n\n\tif (first.scheme !== second.scheme || !isEqualAuthority(first.authority, second.authority)) {\n\t\treturn false;\n\t}\n\n\tconst p1 = first.path || '/', p2 = second.path || '/';\n\treturn p1 === p2 || ignoreCase && equalsIgnoreCase(p1 || '/', p2 || '/');\n}\n\nexport function basename(resource: URI): string {\n\treturn paths.posix.basename(resource.path);\n}\n\nexport function extname(resource: URI): string {\n\treturn paths.posix.extname(resource.path);\n}\n\n/**\n * Return a URI representing the directory of a URI path.\n *\n * @param resource The input URI.\n * @returns The URI representing the directory of the input URI.\n */\nexport function dirname(resource: URI): URI {\n\tif (resource.path.length === 0) {\n\t\treturn resource;\n\t}\n\tif (resource.scheme === Schemas.file) {\n\t\treturn URI.file(paths.dirname(originalFSPath(resource)));\n\t}\n\tlet dirname = paths.posix.dirname(resource.path);\n\tif (resource.authority && dirname.length && dirname.charCodeAt(0) !== CharCode.Slash) {\n\t\tconsole.error(`dirname(\"${resource.toString})) resulted in a relative path`);\n\t\tdirname = '/'; // If a URI contains an authority component, then the path component must either be empty or begin with a CharCode.Slash (\"/\") character\n\t}\n\treturn resource.with({\n\t\tpath: dirname\n\t});\n}\n\n/**\n * Join a URI path with path fragments and normalizes the resulting path.\n *\n * @param resource The input URI.\n * @param pathFragment The path fragment to add to the URI path.\n * @returns The resulting URI.\n */\nexport function joinPath(resource: URI, ...pathFragment: string[]): URI {\n\tlet joinedPath: string;\n\tif (resource.scheme === Schemas.file) {\n\t\tjoinedPath = URI.file(paths.join(originalFSPath(resource), ...pathFragment)).path;\n\t} else {\n\t\tjoinedPath = paths.posix.join(resource.path || '/', ...pathFragment);\n\t}\n\treturn resource.with({\n\t\tpath: joinedPath\n\t});\n}\n\n/**\n * Normalizes the path part of a URI: Resolves `.` and `..` elements with directory names.\n *\n * @param resource The URI to normalize the path.\n * @returns The URI with the normalized path.\n */\nexport function normalizePath(resource: URI): URI {\n\tif (!resource.path.length) {\n\t\treturn resource;\n\t}\n\tlet normalizedPath: string;\n\tif (resource.scheme === Schemas.file) {\n\t\tnormalizedPath = URI.file(paths.normalize(originalFSPath(resource))).path;\n\t} else {\n\t\tnormalizedPath = paths.posix.normalize(resource.path);\n\t}\n\treturn resource.with({\n\t\tpath: normalizedPath\n\t});\n}\n\n/**\n * Returns the fsPath of an URI where the drive letter is not normalized.\n * See #56403.\n */\nexport function originalFSPath(uri: URI): string {\n\tlet value: string;\n\tconst uriPath = uri.path;\n\tif (uri.authority && uriPath.length > 1 && uri.scheme === Schemas.file) {\n\t\t// unc path: file://shares/c$/far/boo\n\t\tvalue = `//${uri.authority}${uriPath}`;\n\t} else if (\n\t\tisWindows\n\t\t&& uriPath.charCodeAt(0) === CharCode.Slash\n\t\t&& extpath.isWindowsDriveLetter(uriPath.charCodeAt(1))\n\t\t&& uriPath.charCodeAt(2) === CharCode.Colon\n\t) {\n\t\tvalue = uriPath.substr(1);\n\t} else {\n\t\t// other path\n\t\tvalue = uriPath;\n\t}\n\tif (isWindows) {\n\t\tvalue = value.replace(/\\//g, '\\\\');\n\t}\n\treturn value;\n}\n\n/**\n * Returns true if the URI path is absolute.\n */\nexport function isAbsolutePath(resource: URI): boolean {\n\treturn !!resource.path && resource.path[0] === '/';\n}\n\n/**\n * Returns true if the URI path has a trailing path separator\n */\nexport function hasTrailingPathSeparator(resource: URI, sep: string = paths.sep): boolean {\n\tif (resource.scheme === Schemas.file) {\n\t\tconst fsp = originalFSPath(resource);\n\t\treturn fsp.length > extpath.getRoot(fsp).length && fsp[fsp.length - 1] === sep;\n\t} else {\n\t\tconst p = resource.path;\n\t\treturn (p.length > 1 && p.charCodeAt(p.length - 1) === CharCode.Slash) && !(/^[a-zA-Z]:(\\/$|\\\\$)/.test(resource.fsPath)); // ignore the slash at offset 0\n\t}\n}\n\n/**\n * Removes a trailing path separator, if there's one.\n * Important: Doesn't remove the first slash, it would make the URI invalid\n */\nexport function removeTrailingPathSeparator(resource: URI, sep: string = paths.sep): URI {\n\t// Make sure that the path isn't a drive letter. A trailing separator there is not removable.\n\tif (hasTrailingPathSeparator(resource, sep)) {\n\t\treturn resource.with({ path: resource.path.substr(0, resource.path.length - 1) });\n\t}\n\treturn resource;\n}\n\n/**\n * Adds a trailing path separator to the URI if there isn't one already.\n * For example, c:\\ would be unchanged, but c:\\users would become c:\\users\\\n */\nexport function addTrailingPathSeparator(resource: URI, sep: string = paths.sep): URI {\n\tlet isRootSep: boolean = false;\n\tif (resource.scheme === Schemas.file) {\n\t\tconst fsp = originalFSPath(resource);\n\t\tisRootSep = ((fsp !== undefined) && (fsp.length === extpath.getRoot(fsp).length) && (fsp[fsp.length - 1] === sep));\n\t} else {\n\t\tsep = '/';\n\t\tconst p = resource.path;\n\t\tisRootSep = p.length === 1 && p.charCodeAt(p.length - 1) === CharCode.Slash;\n\t}\n\tif (!isRootSep && !hasTrailingPathSeparator(resource, sep)) {\n\t\treturn resource.with({ path: resource.path + '/' });\n\t}\n\treturn resource;\n}\n\n/**\n * Returns a relative path between two URIs. If the URIs don't have the same schema or authority, `undefined` is returned.\n * The returned relative path always uses forward slashes.\n */\nexport function relativePath(from: URI, to: URI, ignoreCase = hasToIgnoreCase(from)): string | undefined {\n\tif (from.scheme !== to.scheme || !isEqualAuthority(from.authority, to.authority)) {\n\t\treturn undefined;\n\t}\n\tif (from.scheme === Schemas.file) {\n\t\tconst relativePath = paths.relative(originalFSPath(from), originalFSPath(to));\n\t\treturn isWindows ? extpath.toSlashes(relativePath) : relativePath;\n\t}\n\tlet fromPath = from.path || '/', toPath = to.path || '/';\n\tif (ignoreCase) {\n\t\t// make casing of fromPath match toPath\n\t\tlet i = 0;\n\t\tfor (const len = Math.min(fromPath.length, toPath.length); i < len; i++) {\n\t\t\tif (fromPath.charCodeAt(i) !== toPath.charCodeAt(i)) {\n\t\t\t\tif (fromPath.charAt(i).toLowerCase() !== toPath.charAt(i).toLowerCase()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfromPath = toPath.substr(0, i) + fromPath.substr(i);\n\t}\n\treturn paths.posix.relative(fromPath, toPath);\n}\n\n/**\n * Resolves an absolute or relative path against a base URI.\n * The path can be relative or absolute posix or a Windows path\n */\nexport function resolvePath(base: URI, path: string): URI {\n\tif (base.scheme === Schemas.file) {\n\t\tconst newURI = URI.file(paths.resolve(originalFSPath(base), path));\n\t\treturn base.with({\n\t\t\tauthority: newURI.authority,\n\t\t\tpath: newURI.path\n\t\t});\n\t}\n\tif (path.indexOf('/') === -1) { // no slashes? it's likely a Windows path\n\t\tpath = extpath.toSlashes(path);\n\t\tif (/^[a-zA-Z]:(\\/|$)/.test(path)) { // starts with a drive letter\n\t\t\tpath = '/' + path;\n\t\t}\n\t}\n\treturn base.with({\n\t\tpath: paths.posix.resolve(base.path, path)\n\t});\n}\n\nexport function distinctParents<T>(items: T[], resourceAccessor: (item: T) => URI): T[] {\n\tconst distinctParents: T[] = [];\n\tfor (let i = 0; i < items.length; i++) {\n\t\tconst candidateResource = resourceAccessor(items[i]);\n\t\tif (items.some((otherItem, index) => {\n\t\t\tif (index === i) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn isEqualOrParent(candidateResource, resourceAccessor(otherItem));\n\t\t})) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tdistinctParents.push(items[i]);\n\t}\n\n\treturn distinctParents;\n}\n\n/**\n * Data URI related helpers.\n */\nexport namespace DataUri {\n\n\texport const META_DATA_LABEL = 'label';\n\texport const META_DATA_DESCRIPTION = 'description';\n\texport const META_DATA_SIZE = 'size';\n\texport const META_DATA_MIME = 'mime';\n\n\texport function parseMetaData(dataUri: URI): Map<string, string> {\n\t\tconst metadata = new Map<string, string>();\n\n\t\t// Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\n\t\t// the metadata is: size:2313;label:SomeLabel;description:SomeDescription\n\t\tconst meta = dataUri.path.substring(dataUri.path.indexOf(';') + 1, dataUri.path.lastIndexOf(';'));\n\t\tmeta.split(';').forEach(property => {\n\t\t\tconst [key, value] = property.split(':');\n\t\t\tif (key && value) {\n\t\t\t\tmetadata.set(key, value);\n\t\t\t}\n\t\t});\n\n\t\t// Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\n\t\t// the mime is: image/png\n\t\tconst mime = dataUri.path.substring(0, dataUri.path.indexOf(';'));\n\t\tif (mime) {\n\t\t\tmetadata.set(META_DATA_MIME, mime);\n\t\t}\n\n\t\treturn metadata;\n\t}\n}\n\nexport class ResourceGlobMatcher {\n\n\tprivate readonly globalExpression: ParsedExpression;\n\tprivate readonly expressionsByRoot: TernarySearchTree<{ root: URI, expression: ParsedExpression }> = TernarySearchTree.forPaths<{ root: URI, expression: ParsedExpression }>();\n\n\tconstructor(\n\t\tglobalExpression: IExpression,\n\t\trootExpressions: { root: URI, expression: IExpression }[]\n\t) {\n\t\tthis.globalExpression = parse(globalExpression);\n\t\tfor (const expression of rootExpressions) {\n\t\t\tthis.expressionsByRoot.set(expression.root.toString(), { root: expression.root, expression: parse(expression.expression) });\n\t\t}\n\t}\n\n\tmatches(resource: URI): boolean {\n\t\tconst rootExpression = this.expressionsByRoot.findSubstr(resource.toString());\n\t\tif (rootExpression) {\n\t\t\tconst path = relativePath(rootExpression.root, resource);\n\t\t\tif (path && !!rootExpression.expression(path)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn !!this.globalExpression(resource.path);\n\t}\n}\n\nexport function toLocalResource(resource: URI, authority: string | undefined): URI {\n\tif (authority) {\n\t\tlet path = resource.path;\n\t\tif (path && path[0] !== paths.posix.sep) {\n\t\t\tpath = paths.posix.sep + path;\n\t\t}\n\n\t\treturn resource.with({ scheme: Schemas.vscodeRemote, authority, path });\n\t}\n\n\treturn resource.with({ scheme: Schemas.file });\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IMirrorModel, IWorkerContext } from 'vs/editor/common/services/editorSimpleWorker';\nimport { ILink } from 'vs/editor/common/modes';\nimport { URI } from 'vs/base/common/uri';\nimport * as extpath from 'vs/base/common/extpath';\nimport * as resources from 'vs/base/common/resources';\nimport * as strings from 'vs/base/common/strings';\nimport { Range } from 'vs/editor/common/core/range';\nimport { isWindows } from 'vs/base/common/platform';\nimport { Schemas } from 'vs/base/common/network';\nimport { find } from 'vs/base/common/arrays';\n\nexport interface ICreateData {\n\tworkspaceFolders: string[];\n}\n\nexport interface IResourceCreator {\n\ttoResource: (folderRelativePath: string) => URI | null;\n}\n\nexport class OutputLinkComputer {\n\tprivate patterns = new Map<URI /* folder uri */, RegExp[]>();\n\n\tconstructor(private ctx: IWorkerContext, createData: ICreateData) {\n\t\tthis.computePatterns(createData);\n\t}\n\n\tprivate computePatterns(createData: ICreateData): void {\n\n\t\t// Produce patterns for each workspace root we are configured with\n\t\t// This means that we will be able to detect links for paths that\n\t\t// contain any of the workspace roots as segments.\n\t\tconst workspaceFolders = createData.workspaceFolders\n\t\t\t.sort((resourceStrA, resourceStrB) => resourceStrB.length - resourceStrA.length) // longest paths first (for https://github.com/microsoft/vscode/issues/88121)\n\t\t\t.map(resourceStr => URI.parse(resourceStr));\n\n\t\tfor (const workspaceFolder of workspaceFolders) {\n\t\t\tconst patterns = OutputLinkComputer.createPatterns(workspaceFolder);\n\t\t\tthis.patterns.set(workspaceFolder, patterns);\n\t\t}\n\t}\n\n\tprivate getModel(uri: string): IMirrorModel | undefined {\n\t\tconst models = this.ctx.getMirrorModels();\n\n\t\treturn find(models, model => model.uri.toString() === uri);\n\t}\n\n\tcomputeLinks(uri: string): ILink[] {\n\t\tconst model = this.getModel(uri);\n\t\tif (!model) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst links: ILink[] = [];\n\t\tconst lines = model.getValue().split(/\\r\\n|\\r|\\n/);\n\n\t\t// For each workspace root patterns\n\t\tfor (const [folderUri, folderPatterns] of this.patterns) {\n\t\t\tconst resourceCreator: IResourceCreator = {\n\t\t\t\ttoResource: (folderRelativePath: string): URI | null => {\n\t\t\t\t\tif (typeof folderRelativePath === 'string') {\n\t\t\t\t\t\treturn resources.joinPath(folderUri, folderRelativePath);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tfor (let i = 0, len = lines.length; i < len; i++) {\n\t\t\t\tlinks.push(...OutputLinkComputer.detectLinks(lines[i], i + 1, folderPatterns, resourceCreator));\n\t\t\t}\n\t\t}\n\n\t\treturn links;\n\t}\n\n\tstatic createPatterns(workspaceFolder: URI): RegExp[] {\n\t\tconst patterns: RegExp[] = [];\n\n\t\tconst workspaceFolderPath = workspaceFolder.scheme === Schemas.file ? workspaceFolder.fsPath : workspaceFolder.path;\n\t\tconst workspaceFolderVariants = [workspaceFolderPath];\n\t\tif (isWindows && workspaceFolder.scheme === Schemas.file) {\n\t\t\tworkspaceFolderVariants.push(extpath.toSlashes(workspaceFolderPath));\n\t\t}\n\n\t\tfor (const workspaceFolderVariant of workspaceFolderVariants) {\n\t\t\tconst validPathCharacterPattern = '[^\\\\s\\\\(\\\\):<>\"]';\n\t\t\tconst validPathCharacterOrSpacePattern = `(?:${validPathCharacterPattern}| ${validPathCharacterPattern})`;\n\t\t\tconst pathPattern = `${validPathCharacterOrSpacePattern}+\\\\.${validPathCharacterPattern}+`;\n\t\t\tconst strictPathPattern = `${validPathCharacterPattern}+`;\n\n\t\t\t// Example: /workspaces/express/server.js on line 8, column 13\n\t\t\tpatterns.push(new RegExp(strings.escapeRegExpCharacters(workspaceFolderVariant) + `(${pathPattern}) on line ((\\\\d+)(, column (\\\\d+))?)`, 'gi'));\n\n\t\t\t// Example: /workspaces/express/server.js:line 8, column 13\n\t\t\tpatterns.push(new RegExp(strings.escapeRegExpCharacters(workspaceFolderVariant) + `(${pathPattern}):line ((\\\\d+)(, column (\\\\d+))?)`, 'gi'));\n\n\t\t\t// Example: /workspaces/mankala/Features.ts(45): error\n\t\t\t// Example: /workspaces/mankala/Features.ts (45): error\n\t\t\t// Example: /workspaces/mankala/Features.ts(45,18): error\n\t\t\t// Example: /workspaces/mankala/Features.ts (45,18): error\n\t\t\t// Example: /workspaces/mankala/Features Special.ts (45,18): error\n\t\t\tpatterns.push(new RegExp(strings.escapeRegExpCharacters(workspaceFolderVariant) + `(${pathPattern})(\\\\s?\\\\((\\\\d+)(,(\\\\d+))?)\\\\)`, 'gi'));\n\n\t\t\t// Example: at /workspaces/mankala/Game.ts\n\t\t\t// Example: at /workspaces/mankala/Game.ts:336\n\t\t\t// Example: at /workspaces/mankala/Game.ts:336:9\n\t\t\tpatterns.push(new RegExp(strings.escapeRegExpCharacters(workspaceFolderVariant) + `(${strictPathPattern})(:(\\\\d+))?(:(\\\\d+))?`, 'gi'));\n\t\t}\n\n\t\treturn patterns;\n\t}\n\n\t/**\n\t * Detect links. Made static to allow for tests.\n\t */\n\tstatic detectLinks(line: string, lineIndex: number, patterns: RegExp[], resourceCreator: IResourceCreator): ILink[] {\n\t\tconst links: ILink[] = [];\n\n\t\tpatterns.forEach(pattern => {\n\t\t\tpattern.lastIndex = 0; // the holy grail of software development\n\n\t\t\tlet match: RegExpExecArray | null;\n\t\t\tlet offset = 0;\n\t\t\twhile ((match = pattern.exec(line)) !== null) {\n\n\t\t\t\t// Convert the relative path information to a resource that we can use in links\n\t\t\t\tconst folderRelativePath = strings.rtrim(match[1], '.').replace(/\\\\/g, '/'); // remove trailing \".\" that likely indicate end of sentence\n\t\t\t\tlet resourceString: string | undefined;\n\t\t\t\ttry {\n\t\t\t\t\tconst resource = resourceCreator.toResource(folderRelativePath);\n\t\t\t\t\tif (resource) {\n\t\t\t\t\t\tresourceString = resource.toString();\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tcontinue; // we might find an invalid URI and then we dont want to loose all other links\n\t\t\t\t}\n\n\t\t\t\t// Append line/col information to URI if matching\n\t\t\t\tif (match[3]) {\n\t\t\t\t\tconst lineNumber = match[3];\n\n\t\t\t\t\tif (match[5]) {\n\t\t\t\t\t\tconst columnNumber = match[5];\n\t\t\t\t\t\tresourceString = strings.format('{0}#{1},{2}', resourceString, lineNumber, columnNumber);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresourceString = strings.format('{0}#{1}', resourceString, lineNumber);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst fullMatch = strings.rtrim(match[0], '.'); // remove trailing \".\" that likely indicate end of sentence\n\n\t\t\t\tconst index = line.indexOf(fullMatch, offset);\n\t\t\t\toffset += index + fullMatch.length;\n\n\t\t\t\tconst linkRange = {\n\t\t\t\t\tstartColumn: index + 1,\n\t\t\t\t\tstartLineNumber: lineIndex,\n\t\t\t\t\tendColumn: index + 1 + fullMatch.length,\n\t\t\t\t\tendLineNumber: lineIndex\n\t\t\t\t};\n\n\t\t\t\tif (links.some(link => Range.areIntersectingOrTouching(link.range, linkRange))) {\n\t\t\t\t\treturn; // Do not detect duplicate links\n\t\t\t\t}\n\n\t\t\t\tlinks.push({\n\t\t\t\t\trange: linkRange,\n\t\t\t\t\turl: resourceString\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\treturn links;\n\t}\n}\n\nexport function create(ctx: IWorkerContext, createData: ICreateData): OutputLinkComputer {\n\treturn new OutputLinkComputer(ctx, createData);\n}\n"]}